<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Contaminated Soil Geospatial Analysis</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #0a4d3c;
            --primary-light: #0d6b51;
            --accent: #ff6b35;
            --bg-dark: #0f1419;
            --bg-card: #1a2028;
            --text-primary: #e8eaed;
            --text-secondary: #9aa0a6;
            --border: #2d3748;
            --shadow: rgba(0, 0, 0, 0.3);
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0f1419 0%, #1a2634 100%);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 380px 1fr;
            height: 100vh;
            gap: 0;
        }

        .control-panel {
            background: var(--bg-card);
            border-right: 2px solid var(--border);
            padding: 2rem;
            overflow-y: auto;
            box-shadow: 4px 0 20px var(--shadow);
        }

        .header {
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 2px solid var(--primary);
        }

        h1 {
            font-family: 'Roboto Mono', monospace;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
            line-height: 1.2;
            margin-bottom: 0.5rem;
            letter-spacing: -0.02em;
        }

        .subtitle {
            font-size: 0.875rem;
            color: var(--text-secondary);
            font-weight: 300;
        }

        /* Tab Styles */
        .tabs-container {
            margin-bottom: 1.5rem;
        }

        .tabs {
            display: flex;
            gap: 0.5rem;
            border-bottom: 2px solid var(--border);
            margin-bottom: 1.5rem;
        }

        .tab {
            flex: 1;
            padding: 0.75rem 1rem;
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            color: var(--text-secondary);
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .tab:hover {
            color: var(--text-primary);
            background: rgba(255, 255, 255, 0.05);
        }

        .tab.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Facility Count Buttons */
        .facility-count-btn {
            flex: 1;
            padding: 0.75rem;
            background: var(--bg-dark);
            border: 2px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .facility-count-btn:hover {
            border-color: var(--primary);
            background: rgba(10, 77, 60, 0.2);
        }

        .facility-count-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .section {
            margin-bottom: 2rem;
        }

        .section-title {
            font-family: 'Roboto Mono', monospace;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--accent);
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .landfill-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .landfill-item {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .landfill-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: var(--primary);
            transform: scaleY(0);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .landfill-item:hover {
            border-color: var(--primary-light);
            transform: translateX(4px);
        }

        .landfill-item.selected {
            border-color: var(--primary);
            background: linear-gradient(135deg, rgba(10, 77, 60, 0.2) 0%, rgba(13, 107, 81, 0.1) 100%);
        }

        .landfill-item.selected::before {
            transform: scaleY(1);
        }

        .landfill-name {
            font-weight: 600;
            font-size: 0.95rem;
            margin-bottom: 0.25rem;
            color: var(--text-primary);
        }

        .landfill-company {
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-family: 'Roboto Mono', monospace;
        }

        .radius-control {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1.25rem;
        }

        .radius-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .radius-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent);
            letter-spacing: -0.02em;
        }

        .radius-unit {
            font-size: 0.875rem;
            color: var(--text-secondary);
            font-weight: 400;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: var(--border);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: 3px solid var(--text-primary);
            transition: all 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: var(--primary-light);
            transform: scale(1.15);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: 3px solid var(--text-primary);
            transition: all 0.2s;
        }

        .stats-panel {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-light) 100%);
            border-radius: 8px;
            padding: 1.5rem;
            margin-top: 1.5rem;
        }

        .stat-item {
            margin-bottom: 1.25rem;
        }

        .stat-item:last-child {
            margin-bottom: 0;
        }

        .stat-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 0.25rem;
            font-family: 'Roboto Mono', monospace;
        }

        .stat-value {
            font-size: 1.75rem;
            font-weight: 700;
            color: white;
            font-family: 'Roboto Mono', monospace;
            letter-spacing: -0.02em;
        }

        .stat-unit {
            font-size: 0.875rem;
            color: rgba(255, 255, 255, 0.8);
            font-weight: 400;
            margin-left: 0.25rem;
        }

        .export-btn {
            width: 100%;
            padding: 1rem;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: 'Roboto Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-top: 1.5rem;
            box-shadow: 0 4px 12px rgba(255, 107, 53, 0.3);
        }

        .export-btn:hover {
            background: #ff8359;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 53, 0.4);
        }

        .export-btn:active {
            transform: translateY(0);
        }

        .export-btn:disabled {
            background: var(--border);
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        .upload-container {
            background: var(--bg-dark);
            border: 2px dashed var(--border);
            border-radius: 8px;
            padding: 1.5rem;
            text-align: center;
            transition: all 0.3s;
        }

        .upload-container:hover {
            border-color: var(--primary);
        }

        .upload-btn {
            padding: 0.875rem 1.5rem;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: 'Roboto Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .upload-btn:hover {
            background: var(--primary-light);
            transform: translateY(-2px);
        }

        .file-name {
            margin-top: 0.75rem;
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-family: 'Roboto Mono', monospace;
        }

        .date-filter-container {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1.25rem;
        }

        .date-slider-container {
            margin-bottom: 1.5rem;
        }

        .date-slider-wrapper {
            position: relative;
            height: 60px;
            margin: 1rem 0;
        }

        .date-slider-track {
            position: absolute;
            top: 25px;
            left: 0;
            right: 0;
            height: 6px;
            background: var(--border);
            border-radius: 3px;
        }

        .date-slider-range {
            position: absolute;
            top: 25px;
            height: 6px;
            background: var(--primary);
            border-radius: 3px;
            pointer-events: none;
        }

        .date-slider {
            position: absolute;
            width: 100%;
            top: 22px;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            pointer-events: none;
        }

        .date-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: 3px solid var(--text-primary);
            pointer-events: auto;
        }

        .date-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: 3px solid var(--text-primary);
            pointer-events: auto;
        }

        .date-slider::-webkit-slider-thumb:hover {
            background: var(--primary-light);
            transform: scale(1.15);
        }

        .date-slider-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 0.5rem;
            font-size: 0.75rem;
            color: var(--text-secondary);
            font-family: 'Roboto Mono', monospace;
        }

        .date-slider-values {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
            color: var(--text-primary);
            font-weight: 600;
            font-family: 'Roboto Mono', monospace;
        }

        .filter-info {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
            font-style: italic;
        }

        .search-box {
            margin-bottom: 0.75rem;
        }

        .search-input {
            width: 100%;
            padding: 0.625rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.85rem;
            font-family: 'Inter', sans-serif;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary);
        }

        .filter-list {
            max-height: 200px;
            overflow-y: auto;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0.5rem;
        }

        .filter-item {
            display: flex;
            align-items: center;
            padding: 0.5rem;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.2s;
            margin-bottom: 0.25rem;
        }

        .filter-item:hover {
            background: rgba(10, 77, 60, 0.2);
        }

        .filter-item input[type="checkbox"] {
            margin-right: 0.5rem;
            cursor: pointer;
        }

        .filter-item label {
            font-size: 0.85rem;
            color: var(--text-primary);
            cursor: pointer;
            flex: 1;
        }

        .filter-clear-btn {
            width: 100%;
            padding: 0.625rem;
            margin-top: 0.5rem;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Roboto Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .filter-clear-btn:hover {
            background: var(--border);
            color: var(--text-primary);
        }

        .sheet-selector {
            width: 100%;
            padding: 0.75rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.9rem;
            font-family: 'Roboto Mono', monospace;
            margin-bottom: 1rem;
            cursor: pointer;
        }

        .sheet-selector:focus {
            outline: none;
            border-color: var(--primary);
        }

        .date-input-group {
            margin-bottom: 1rem;
        }

        .date-input-group label {
            display: block;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            font-family: 'Roboto Mono', monospace;
        }

        .date-input {
            width: 100%;
            padding: 0.75rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.9rem;
            font-family: 'Roboto Mono', monospace;
            transition: border-color 0.3s;
        }

        .date-input:focus {
            outline: none;
            border-color: var(--primary);
        }

        .filter-btn {
            width: 100%;
            padding: 0.875rem;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: 'Roboto Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
        }

        .filter-btn:hover {
            background: var(--primary-light);
            transform: translateY(-2px);
        }

        .reset-btn {
            background: var(--border);
            margin-bottom: 0;
        }

        .reset-btn:hover {
            background: #3d4a5c;
        }

        .date-range-display {
            margin-top: 1rem;
            padding: 0.75rem;
            background: var(--bg-dark);
            border-radius: 6px;
            font-size: 0.85rem;
            color: var(--text-secondary);
            text-align: center;
            font-family: 'Roboto Mono', monospace;
        }

        #map {
            height: 100vh;
            background: #1a2634;
        }

        .map-legend {
            background: var(--bg-card);
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px var(--shadow);
            border: 1px solid var(--border);
        }

        .legend-title {
            font-family: 'Roboto Mono', monospace;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--accent);
            margin-bottom: 0.75rem;
            font-weight: 600;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
        }

        .legend-item:last-child {
            margin-bottom: 0;
        }

        .legend-marker {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-right: 0.5rem;
            border: 2px solid rgba(255, 255, 255, 0.5);
        }

        .marker-well {
            background: #4a9eff;
        }

        .marker-landfill {
            background: var(--accent);
        }

        .marker-active {
            background: #ffd700;
        }

        .loading {
            display: none;
            padding: 1rem;
            background: var(--bg-dark);
            border-radius: 8px;
            text-align: center;
            margin-bottom: 1rem;
            border: 1px solid var(--border);
        }

        .loading.active {
            display: block;
        }

        .loading-text {
            font-family: 'Roboto Mono', monospace;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }

        /* AI Analytics Assistant Styles */
        .ai-assistant {
            margin-top: 1rem;
            border: 2px solid var(--primary);
            border-radius: 8px;
            background: var(--bg-dark);
            overflow: hidden;
        }

        .ai-header {
            background: var(--primary);
            color: white;
            padding: 0.75rem 1rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }

        .ai-header:hover {
            background: #3a7fd5;
        }

        .ai-title {
            font-weight: 600;
            font-size: 1rem;
        }

        .ai-toggle {
            font-size: 1.2rem;
            transition: transform 0.3s;
        }

        .ai-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .ai-content {
            max-height: 600px;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .ai-content.collapsed {
            max-height: 0;
        }

        .ai-chat-container {
            display: flex;
            flex-direction: column;
            height: 500px;
        }

        .ai-suggestions {
            padding: 0.75rem;
            border-bottom: 1px solid var(--border);
            background: var(--bg-light);
        }

        .suggestion-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .suggestion-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .suggestion-chip {
            padding: 0.25rem 0.75rem;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 12px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .suggestion-chip:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .ai-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            background: var(--bg-light);
        }

        .ai-message {
            margin-bottom: 1rem;
            padding: 0.75rem;
            border-radius: 8px;
            max-width: 90%;
        }

        .ai-message.user {
            background: var(--primary);
            color: white;
            margin-left: auto;
        }

        .ai-message.assistant {
            background: var(--bg-dark);
            border: 1px solid var(--border);
        }

        .message-content {
            font-size: 0.875rem;
            line-height: 1.5;
            white-space: pre-wrap;
        }

        .ai-chart {
            margin-top: 1rem;
            padding: 1rem;
            background: white;
            border-radius: 4px;
        }

        .ai-input-area {
            padding: 1rem;
            border-top: 1px solid var(--border);
            background: var(--bg-dark);
        }

        .ai-input-container {
            display: flex;
            gap: 0.5rem;
        }

        .ai-input {
            flex: 1;
            padding: 0.75rem;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--bg-light);
            color: var(--text-primary);
            font-size: 0.875rem;
        }

        .ai-input:focus {
            outline: none;
            border-color: var(--primary);
        }

        .ai-send-btn {
            padding: 0.75rem 1.5rem;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s;
        }

        .ai-send-btn:hover:not(:disabled) {
            background: #3a7fd5;
        }

        .ai-send-btn:disabled {
            background: var(--border);
            cursor: not-allowed;
        }

        .ai-loading {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 8px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .ai-loading-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @media (max-width: 1024px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
            }

            .control-panel {
                border-right: none;
                border-bottom: 2px solid var(--border);
                max-height: 50vh;
            }

            #map {
                height: 50vh;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="control-panel">
            <div class="header">
                <h1>Contaminated Soil<br>Geospatial Analysis</h1>
                <div class="subtitle">Distance-based volume tracking system</div>
            </div>

            <div class="section" id="uploadSection">
                <div class="section-title">Load Data File</div>
                <div class="upload-container">
                    <input type="file" id="fileInput" accept=".xlsx,.xls" style="display: none;">
                    <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                        Choose Excel File
                    </button>
                    <div class="file-name" id="fileName">No file selected</div>
                </div>
                <button class="filter-clear-btn" id="resetBtn" onclick="resetApp()" style="display: none; margin-top: 1rem;">
                    üîÑ Load New File
                </button>
            </div>

            <div class="section" id="sheetSelectionSection" style="display: none;">
                <div class="section-title">Select Data Worksheet</div>
                <div class="filter-info">Choose the worksheet containing your soil tracking data</div>
                <select id="sheetSelector" class="sheet-selector">
                    <option value="">-- Select a worksheet --</option>
                </select>
                <button class="filter-btn" id="loadSheetBtn">Load Data</button>
            </div>

            <div class="loading" id="loading">
                <div class="loading-text">Loading data...</div>
            </div>

            <!-- Global Filters (Apply to All Data) -->
            <div style="padding: 1rem 0; margin-bottom: 1rem; border-bottom: 1px solid var(--border);" id="globalFiltersSection">
                <div style="font-size: 0.7rem; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 1rem;">
                    üåç Global Filters (apply to all data)
                </div>
            
            <div class="section" id="dateRangeSection" style="display: none;">
                <div class="section-title">Date Range Filter</div>
                <div class="date-filter-container">
                    <div class="date-slider-container">
                        <div class="date-slider-values">
                            <span id="sliderStartDate">Jan 1, 2024</span>
                            <span id="sliderEndDate">Dec 26, 2025</span>
                        </div>
                        <div class="date-slider-wrapper">
                            <div class="date-slider-track"></div>
                            <div class="date-slider-range" id="sliderRange"></div>
                            <input type="range" id="dateSliderStart" class="date-slider" min="0" max="100" value="0">
                            <input type="range" id="dateSliderEnd" class="date-slider" min="0" max="100" value="100">
                        </div>
                        <div class="date-slider-labels">
                            <span id="dataMinDate">Oldest</span>
                            <span id="dataMaxDate">Newest</span>
                        </div>
                    </div>
                    
                    <div class="date-input-group">
                        <label for="startDate">From:</label>
                        <input type="date" id="startDate" class="date-input">
                    </div>
                    <div class="date-input-group">
                        <label for="endDate">To:</label>
                        <input type="date" id="endDate" class="date-input">
                    </div>
                    <button class="filter-btn" id="applyDateFilter">Apply Filter</button>
                    <button class="filter-btn reset-btn" id="resetDateFilter">Reset</button>
                </div>
                <div class="date-range-display" id="dateRangeDisplay"></div>
            </div>

            <!-- Permian Basin Filter -->
            <div class="section" id="permianBasinSection" style="display: none;">
                <div class="section-title">Geographic Region Filter</div>
                <div class="checkbox-container" style="background: rgba(46, 204, 113, 0.1); padding: 0.75rem; border-radius: 8px; border: 1px solid rgba(46, 204, 113, 0.3);">
                    <label style="display: flex; align-items: center; cursor: pointer; font-weight: 500;">
                        <input type="checkbox" id="permianBasinOnly" style="margin-right: 0.5rem; width: 18px; height: 18px; cursor: pointer;">
                        <span>üó∫Ô∏è Permian Basin Only</span>
                    </label>
                    <div class="filter-info" style="margin-top: 0.5rem; font-size: 0.85rem;">
                        Includes wells in West Texas and SE New Mexico<br>
                        <small style="color: var(--text-secondary);">(Lat: 30.5¬∞-33.5¬∞N, Lng: -105¬∞--100.5¬∞W)</small>
                    </div>
                </div>
                <div class="filter-info" style="margin-top: 0.75rem; color: var(--accent);">
                    <span id="permianFilteredCount">0</span> wells (<span id="permianFilteredVolume">0</span> CY) outside Permian Basin
                </div>
            </div>

            <div class="section" id="distanceFromCenterSection" style="display: none;">
                <div class="section-title">Distance from Dataset Center</div>
                <div class="filter-info">Filter out wells beyond X miles from the geographic center</div>
                <div class="radius-control">
                    <div class="radius-display">
                        <span class="radius-value" id="maxDistanceValue">150</span>
                        <span class="radius-unit">miles max</span>
                    </div>
                    <input type="range" id="maxDistanceSlider" min="50" max="1000" value="150" step="10">
                    <div class="date-slider-labels" style="margin-top: 0.5rem;">
                        <span>50 mi</span>
                        <span>1000 mi</span>
                    </div>
                </div>
                <div class="filter-info" style="margin-top: 0.75rem; color: var(--accent);">
                    <span id="filteredOutCount">0</span> wells (<span id="filteredOutVolume">0</span> CY) filtered out
                </div>
            </div>

            </div> <!-- End globalFiltersSection -->

            <!-- Tabs Container -->
            <div class="tabs-container" id="tabsContainer" style="display: none;">
                <div class="tabs">
                    <button class="tab active" onclick="switchTab('filters')">
                        üìä Data Filters
                    </button>
                    <button class="tab" onclick="switchTab('facility')">
                        üí∞ Facility Analyzer
                    </button>
                </div>

                <!-- Tab 1: Data Filters -->
                <div class="tab-content active" id="filtersTab">

            <div class="section" id="landfillSection" style="display: none;">
                <div class="section-title">Select Landfills</div>
                <div class="landfill-list" id="landfillList"></div>
            </div>

            <div class="section" id="radiusSection" style="display: none;">
                <div class="section-title">Search Radius</div>
                <div class="radius-control">
                    <div class="radius-display">
                        <span class="radius-value" id="radiusValue">25</span>
                        <span class="radius-unit">miles</span>
                    </div>
                    <input type="range" id="radiusSlider" min="1" max="600" value="25" step="1">
                </div>
            </div>

            <!-- Moved from later - Results should be in Tab 1 -->
            <div class="stats-panel" id="statsPanel" style="display: none;">
                <div class="stat-item">
                    <div class="stat-label">Well Sites in Range</div>
                    <div class="stat-value" id="wellCount">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Total Volume</div>
                    <div class="stat-value">
                        <span id="totalVolume">0</span>
                        <span class="stat-unit">CY</span>
                    </div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Selected Landfills</div>
                    <div class="stat-value" id="landfillCount">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Wells >100mi from Center</div>
                    <div class="stat-value" id="outlierCount">0</div>
                </div>
            </div>
            
            <!-- Coordinate Source Breakdown -->
            <div class="stats-panel" id="coordSourcePanel" style="display: none; margin-top: 1rem; border-top: 2px solid var(--border); padding-top: 1rem;">
                <div style="font-weight: 600; color: var(--text); margin-bottom: 0.75rem; font-size: 0.95rem;">
                    üìç Volume by Coordinate Source
                </div>
                <div class="stat-item" style="background: rgba(46, 204, 113, 0.1);">
                    <div class="stat-label">From API Lookup</div>
                    <div class="stat-value">
                        <span id="apiCoordVolume">0</span>
                        <span class="stat-unit">CY</span>
                        <span style="font-size: 0.75rem; color: var(--text-light); margin-left: 0.5rem;">(<span id="apiCoordPct">0</span>%)</span>
                    </div>
                </div>
                <div class="stat-item" style="background: rgba(52, 152, 219, 0.1);">
                    <div class="stat-label">From EA Data</div>
                    <div class="stat-value">
                        <span id="eaCoordVolume">0</span>
                        <span class="stat-unit">CY</span>
                        <span style="font-size: 0.75rem; color: var(--text-light); margin-left: 0.5rem;">(<span id="eaCoordPct">0</span>%)</span>
                    </div>
                </div>
                <div class="stat-item" style="background: rgba(241, 196, 15, 0.1);">
                    <div class="stat-label">From County Centroid</div>
                    <div class="stat-value">
                        <span id="countyCoordVolume">0</span>
                        <span class="stat-unit">CY</span>
                        <span style="font-size: 0.75rem; color: var(--text-light); margin-left: 0.5rem;">(<span id="countyCoordPct">0</span>%)</span>
                    </div>
                </div>
                <div class="stat-item" style="background: rgba(231, 76, 60, 0.1);">
                    <div class="stat-label">From Landfill County</div>
                    <div class="stat-value">
                        <span id="landfillCountyVolume">0</span>
                        <span class="stat-unit">CY</span>
                        <span style="font-size: 0.75rem; color: var(--text-light); margin-left: 0.5rem;">(<span id="landfillCountyPct">0</span>%)</span>
                    </div>
                </div>
            </div>

            <button class="export-btn" id="exportBtn" style="display: none;">Export Results to Excel</button>
            
            <button class="export-btn" id="orlaExportBtn" style="display: none; background: var(--primary); margin-top: 1rem;">
                Export Outlier Wells >100 Miles
            </button>

            <button class="export-btn" id="badCoordsExportBtn" style="display: none; background: var(--danger); margin-top: 1rem;">
                ‚ö†Ô∏è Export Bad Coordinates (<span id="badCoordsCount">0</span> rows)
            </button>

            <div class="section" id="generatorSection" style="display: none;">
                <div class="section-title">Filter by Generator</div>
                <div class="filter-info">Optional: Select specific operators</div>
                <div class="search-box">
                    <input type="text" id="generatorSearch" class="search-input" placeholder="Search generators...">
                </div>
                <div class="filter-list" id="generatorList"></div>
                <button class="filter-clear-btn" id="selectAllGenerators">Select All</button>
                <button class="filter-clear-btn" id="clearGenerators">Clear All</button>
            </div>

            <div class="section" id="transporterSection" style="display: none;">
                <div class="section-title">Filter by Transporter</div>
                <div class="filter-info">Optional: Select specific transporters</div>
                <div class="search-box">
                    <input type="text" id="transporterSearch" class="search-input" placeholder="Search transporters...">
                </div>
                <div class="filter-list" id="transporterList"></div>
                <button class="filter-clear-btn" id="selectAllTransporters">Select All</button>
                <button class="filter-clear-btn" id="clearTransporters">Clear All</button>
            </div>

                </div> <!-- End filtersTab -->

                <!-- Tab 2: Facility Analyzer -->
                <div class="tab-content" id="facilityTab">

            <div class="section" id="volumeCenterSection" style="display: none;">
                <div class="section-title">Strategic Facility Placement</div>
                <div class="date-filter-container">
                    <div class="filter-info" style="margin-bottom: 1rem;">
                        <strong>Volume-Weighted Center:</strong> Optimal location based on soil generation volume
                    </div>
                    <div class="stat-item" style="margin-bottom: 0.5rem;">
                        <div class="stat-label">Coordinates</div>
                        <div class="stat-value" style="font-size: 0.85rem; font-family: 'Roboto Mono', monospace;">
                            <span id="volumeCenterCoords">--</span>
                        </div>
                    </div>
                    <div class="stat-item" style="margin-bottom: 0.5rem;">
                        <div class="stat-label">Total Volume in Dataset</div>
                        <div class="stat-value">
                            <span id="volumeCenterTotal">0</span>
                            <span class="stat-unit">CY</span>
                        </div>
                    </div>
                    <div class="filter-info" style="margin-top: 0.75rem; color: var(--text-secondary); font-size: 0.75rem;">
                        üìç Purple marker on map shows volume-weighted optimal location
                    </div>
                    <div class="filter-info" style="margin-top: 0.5rem; color: var(--text-secondary); font-size: 0.75rem;">
                        üí° Adjust date range to see how optimal location shifts seasonally
                    </div>
                </div>
            </div>

            <div class="section" id="myFacilitySection" style="display: none;">
                <div class="section-title">üè≠ Facility Placement & Revenue Analyzer</div>
                
                <div class="filter-info" style="margin-bottom: 1.5rem; padding: 1rem; background: var(--bg-dark); border-left: 4px solid var(--accent); border-radius: 6px;">
                    <strong style="color: var(--accent);">How It Works:</strong><br>
                    1Ô∏è‚É£ Click "Add Facility" or "Auto-Place All" to start<br>
                    2Ô∏è‚É£ <strong>Drag facilities</strong> on the map to reposition<br>
                    3Ô∏è‚É£ Watch revenue update in real-time as you move them<br>
                    4Ô∏è‚É£ Add/remove facilities to test different scenarios (max 6)
                </div>
                
                <!-- Facility Management Controls -->
                <div class="date-filter-container" style="margin-bottom: 1.5rem;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin-bottom: 1rem;">
                        <button class="filter-btn" id="addFacilityBtn">
                            ‚ûï Add Facility
                        </button>
                        <button class="filter-btn" id="autoPlaceBtn" style="background: var(--accent);">
                            üéØ Auto-Place All
                        </button>
                    </div>
                    
                    <button class="filter-clear-btn" id="clearAllFacilitiesBtn" style="width: 100%;">
                        ‚ùå Clear All Facilities
                    </button>
                </div>
                
                <!-- Configuration Parameters -->
                <div class="date-filter-container" style="margin-bottom: 2rem;">
                    <div class="filter-info" style="margin-bottom: 1rem;">
                        <strong>‚öôÔ∏è Configuration</strong>
                    </div>
                    
                    
                    <!-- Market Share -->
                    <div style="margin-bottom: 1.5rem;">
                        <div class="stat-label">Market Share (%)</div>
                        <div class="radius-control">
                            <div class="radius-display">
                                <span class="radius-value" id="facilityMarketShare">30</span>
                                <span class="radius-unit">%</span>
                            </div>
                            <input type="range" id="facilityMarketShareSlider" min="1" max="100" value="30" step="1">
                        </div>
                    </div>
                    
                    <!-- Disposal Price -->
                    <div style="margin-bottom: 1.5rem;">
                        <div class="stat-label">Disposal Price per Cubic Yard</div>
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <span style="color: var(--text-secondary);">$</span>
                            <input type="number" id="facilityDisposalPrice" value="25" min="1" max="200" step="0.50"
                                   style="flex: 1; padding: 0.75rem; background: var(--bg-dark); border: 1px solid var(--border); border-radius: 4px; color: var(--text-primary);">
                            <span style="color: var(--text-secondary);">/ CY</span>
                        </div>
                    </div>
                    
                    <!-- Backfill Price -->
                    <div style="margin-bottom: 1.5rem;">
                        <div class="stat-label">Backfill Price per Cubic Yard</div>
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <span style="color: var(--text-secondary);">$</span>
                            <input type="number" id="facilityBackfillPrice" value="10" min="0" max="100" step="0.50"
                                   style="flex: 1; padding: 0.75rem; background: var(--bg-dark); border: 1px solid var(--border); border-radius: 4px; color: var(--text-primary);">
                            <span style="color: var(--text-secondary);">/ CY</span>
                        </div>
                    </div>
                    
                    <!-- Backfill Percentage -->
                    <div style="margin-bottom: 1.5rem;">
                        <div class="stat-label">Backfill Purchase %</div>
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <input type="number" id="facilityBackfillPercentage" value="90" min="0" max="100" step="1"
                                   style="flex: 1; padding: 0.75rem; background: var(--bg-dark); border: 1px solid var(--border); border-radius: 4px; color: var(--text-primary);">
                            <span style="color: var(--text-secondary);">%</span>
                        </div>
                    </div>
                    
                    <!-- Minimum Spacing -->
                    <div style="margin-bottom: 1.5rem;">
                        <div class="stat-label">Minimum Spacing Between Facilities</div>
                        <div class="filter-info" style="font-size: 0.75rem; margin-bottom: 0.5rem;">
                            Used during auto-placement (not enforced during manual drag)
                        </div>
                        <div class="radius-control">
                            <div class="radius-display">
                                <span class="radius-value" id="facilityMinSpacing">30</span>
                                <span class="radius-unit">miles</span>
                            </div>
                            <input type="range" id="facilityMinSpacingSlider" min="0" max="200" value="30" step="10">
                        </div>
                    </div>
                    
                </div>
                
                <!-- Active Facilities List -->
                <div id="activeFacilitiesList" style="display: none; margin-bottom: 2rem;">
                    <div class="filter-info" style="margin-bottom: 1rem; font-weight: 600;">
                        üìç Active Facilities (<span id="facilityCount">0</span>)
                    </div>
                    <div id="facilitiesContainer"></div>
                </div>
                
                <!-- Combined Results -->
                <div id="combinedResults" style="display: none;">
                    <div class="filter-info" style="margin-bottom: 1rem; font-weight: 600; color: var(--accent);">
                        üí∞ Combined Results
                    </div>
                    
                    <div style="background: var(--bg-dark); border: 2px solid var(--primary); border-radius: 8px; padding: 1rem;">
                        <div class="stat-item" style="margin-bottom: 0.75rem;">
                            <div class="stat-label">Total Wells Captured</div>
                            <div class="stat-value" style="color: var(--primary);" id="combinedTotalWells">0</div>
                        </div>
                        <div class="stat-item" style="margin-bottom: 0.75rem;">
                            <div class="stat-label">Total Available Volume</div>
                            <div class="stat-value" style="color: var(--primary);">
                                <span id="combinedTotalAvailable">0</span>
                                <span class="stat-unit">CY</span>
                            </div>
                        </div>
                        <div class="stat-item" style="margin-bottom: 0.75rem;">
                            <div class="stat-label">Total Captured Volume</div>
                            <div class="stat-value" style="color: var(--accent); font-size: 1.3rem;">
                                <span id="combinedTotalCaptured">0</span>
                                <span class="stat-unit">CY</span>
                            </div>
                        </div>
                        
                        <!-- Period Revenue Breakdown -->
                        <div style="margin: 1.25rem 0; padding-top: 0.75rem; border-top: 2px solid var(--border);">
                            <div style="font-weight: 600; color: var(--primary); margin-bottom: 0.5rem;">üìä Period Revenue</div>
                        </div>
                        <div class="stat-item" style="margin-bottom: 0.5rem;">
                            <div class="stat-label" style="padding-left: 1rem;">Disposal Revenue</div>
                            <div class="stat-value" style="color: var(--text-secondary); font-size: 0.95rem;">
                                $<span id="combinedDisposalRevenuePeriod">0</span>
                            </div>
                        </div>
                        <div class="stat-item" style="margin-bottom: 0.5rem;">
                            <div class="stat-label" style="padding-left: 1rem;">Backfill Revenue</div>
                            <div class="stat-value" style="color: var(--text-secondary); font-size: 0.95rem;">
                                $<span id="combinedBackfillRevenuePeriod">0</span>
                            </div>
                        </div>
                        <div class="stat-item" style="margin-bottom: 0.75rem;">
                            <div class="stat-label">Total Period Revenue</div>
                            <div class="stat-value" style="color: var(--primary); font-size: 1.2rem; font-weight: 600;">
                                $<span id="combinedPeriodRevenue">0</span>
                            </div>
                        </div>
                        
                        <!-- Annual Revenue Breakdown -->
                        <div style="margin: 1.25rem 0; padding-top: 0.75rem; border-top: 2px solid var(--border);">
                            <div style="font-weight: 600; color: var(--accent); margin-bottom: 0.5rem;">üìà Annualized Revenue</div>
                        </div>
                        <div class="stat-item" style="margin-bottom: 0.5rem;">
                            <div class="stat-label" style="padding-left: 1rem;">Disposal Revenue</div>
                            <div class="stat-value" style="color: var(--text-secondary); font-size: 0.95rem;">
                                $<span id="combinedDisposalRevenue">0</span>
                            </div>
                        </div>
                        <div class="stat-item" style="margin-bottom: 0.5rem;">
                            <div class="stat-label" style="padding-left: 1rem;">Backfill Revenue</div>
                            <div class="stat-value" style="color: var(--text-secondary); font-size: 0.95rem;">
                                $<span id="combinedBackfillRevenue">0</span>
                            </div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label" style="font-size: 1rem; font-weight: 700;">Total Annual Revenue</div>
                            <div class="stat-value" style="color: var(--accent); font-size: 1.5rem; font-weight: 700;">
                                $<span id="combinedAnnualRevenue">0</span>
                            </div>
                        </div>
                        
                        <!-- Coordinate Source Breakdown -->
                        <div style="margin: 1.25rem 0; padding-top: 0.75rem; border-top: 2px solid var(--border);">
                            <div style="font-weight: 600; color: var(--primary); margin-bottom: 0.75rem;">üìç Volume by Coordinate Source</div>
                        </div>
                        <div class="stat-item" style="background: rgba(46, 204, 113, 0.1); margin-bottom: 0.5rem; padding: 0.5rem;">
                            <div class="stat-label">From API Lookup</div>
                            <div class="stat-value">
                                <span id="facilityApiCoordVolume">0</span>
                                <span class="stat-unit">CY</span>
                                <span style="font-size: 0.75rem; color: var(--text-light); margin-left: 0.5rem;">(<span id="facilityApiCoordPct">0</span>%)</span>
                            </div>
                        </div>
                        <div class="stat-item" style="background: rgba(52, 152, 219, 0.1); margin-bottom: 0.5rem; padding: 0.5rem;">
                            <div class="stat-label">From EA Data</div>
                            <div class="stat-value">
                                <span id="facilityEaCoordVolume">0</span>
                                <span class="stat-unit">CY</span>
                                <span style="font-size: 0.75rem; color: var(--text-light); margin-left: 0.5rem;">(<span id="facilityEaCoordPct">0</span>%)</span>
                            </div>
                        </div>
                        <div class="stat-item" style="background: rgba(241, 196, 15, 0.1); margin-bottom: 0.5rem; padding: 0.5rem;">
                            <div class="stat-label">From County Centroid</div>
                            <div class="stat-value">
                                <span id="facilityCountyCoordVolume">0</span>
                                <span class="stat-unit">CY</span>
                                <span style="font-size: 0.75rem; color: var(--text-light); margin-left: 0.5rem;">(<span id="facilityCountyCoordPct">0</span>%)</span>
                            </div>
                        </div>
                        <div class="stat-item" style="background: rgba(231, 76, 60, 0.1); padding: 0.5rem;">
                            <div class="stat-label">From Landfill County</div>
                            <div class="stat-value">
                                <span id="facilityLandfillCountyVolume">0</span>
                                <span class="stat-unit">CY</span>
                                <span style="font-size: 0.75rem; color: var(--text-light); margin-left: 0.5rem;">(<span id="facilityLandfillCountyPct">0</span>%)</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

                </div> <!-- End facilityTab -->
            </div> <!-- End tabsContainer -->

            <!-- AI Analytics Assistant -->
            <div class="ai-assistant" id="aiAssistant" style="display: none;">
                <div class="ai-header" onclick="toggleAIAssistant()">
                    <div class="ai-title">ü§ñ AI Analytics Assistant</div>
                    <div class="ai-toggle" id="aiToggle">‚ñº</div>
                </div>
                <div class="ai-content" id="aiContent">
                    <div class="ai-chat-container">
                        <div class="ai-suggestions">
                            <div class="suggestion-label">API Key (required):</div>
                            <div style="display: flex; gap: 0.5rem; margin-bottom: 0.75rem;">
                                <input type="password" id="anthropicApiKey" class="ai-input" 
                                       placeholder="Enter your Anthropic API key (sk-ant-...)" 
                                       style="flex: 1; font-size: 0.75rem;">
                                <button onclick="saveApiKey()" style="padding: 0.5rem 1rem; background: var(--primary); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.75rem;">Save</button>
                            </div>
                            <div class="suggestion-label">Try asking:</div>
                            <div class="suggestion-chips">
                                <div class="suggestion-chip" onclick="askSuggestion('Who are the top 5 generators by volume?')">Top generators</div>
                                <div class="suggestion-chip" onclick="askSuggestion('Show volume trends by month')">Monthly trends</div>
                                <div class="suggestion-chip" onclick="askSuggestion('Which transporter has the longest haul distance?')">Haul distances</div>
                                <div class="suggestion-chip" onclick="askSuggestion('Compare landfill usage over time')">Landfill comparison</div>
                            </div>
                        </div>
                        <div class="ai-messages" id="aiMessages"></div>
                        <div class="ai-input-area">
                            <div class="ai-input-container">
                                <input type="text" id="aiInput" class="ai-input" placeholder="Ask a question about your data..." 
                                       onkeypress="if(event.key==='Enter') sendAIMessage()">
                                <button class="ai-send-btn" id="aiSendBtn" onclick="sendAIMessage()">Send</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="map"></div>
    </div>

    <script>
        // Tab Switching
        function switchTab(tab) {
            const filtersTab = document.getElementById('filtersTab');
            const facilityTab = document.getElementById('facilityTab');
            const filterButton = document.querySelector('.tab[onclick*="filters"]');
            const facilityButton = document.querySelector('.tab[onclick*="facility"]');
            
            if (tab === 'filters') {
                filtersTab.classList.add('active');
                facilityTab.classList.remove('active');
                filterButton.classList.add('active');
                facilityButton.classList.remove('active');
            } else if (tab === 'facility') {
                facilityTab.classList.add('active');
                filtersTab.classList.remove('active');
                facilityButton.classList.add('active');
                filterButton.classList.remove('active');
            }
        }

                // Data storage
        let rawDailyData = []; // Store original daily transactions
        let wellData = []; // Aggregated well data
        let filteredWellData = []; // Data after date filtering
        let landfills = [];
        let map, radiusCircles = [], wellMarkers = [], landfillMarkers = {};
        let centerpointMarker = null; // Marker for dataset geographic center
        let volumeCenterMarker = null; // Marker for volume-weighted center (strategic placement)
        let myFacilityMarker = null; // Marker for user's proposed facility
        let myFacilityCircle = null; // Radius circle for user's facility
        let myFacilityLocation = null; // { lat, lng } for user's facility
        let myFacilityRadius = 50; // Service radius in miles
        let myFacilityMarketShare = 30; // Market share percentage
        let myFacilityPrice = 25; // Price per CY
        let myFacilityBackfillPrice = 10; // Backfill price per CY
        let myFacilityBackfillPercentage = 90; // Percentage of volume backfilled
        let placementMode = false; // Whether user is placing facility
        let selectedLandfills = new Set();
        let currentRadius = 25;
        let minDate, maxDate; // Date range from data
        let filterStartDate, filterEndDate; // User-selected filter dates
        let selectedFile = null; // Store selected file
        let workbookData = null; // Store workbook for sheet selection
        let totalOutlierCount = 0; // Total wells >100mi from center (entire dataset)
        let maxDistanceFromCenter = 150; // Maximum distance from center (miles) - for filtering
        let datasetCenter = null; // Geographic center of dataset { lat, lng }
        let permianBasinOnly = false; // Global filter: only show wells in Permian Basin
        let badCoordinateRows = []; // Track rows with invalid/missing coordinates for export

        // AI Assistant variables
        let conversationHistory = [];
        let aiAssistantCollapsed = false;

        // Helper function to format numbers with comma thousand separators
        function formatNumber(num, decimals = 0) {
            if (num === null || num === undefined || isNaN(num)) return '0';
            return num.toFixed(decimals).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        }

        // Initialize map
        function initMap() {
            map = L.map('map').setView([31.5, -102.5], 7);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);

            // Add legend
            const legend = L.control({ position: 'bottomright' });
            legend.onAdd = function() {
                const div = L.DomUtil.create('div', 'map-legend');
                div.innerHTML = `
                    <div class="legend-title">Map Legend</div>
                    <div class="legend-item">
                        <div class="legend-marker marker-well"></div>
                        <span>Well Sites</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-marker marker-landfill"></div>
                        <span>Landfills</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-marker marker-active"></div>
                        <span>Wells in Range</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-marker" style="background: #00ff00; border: 2px solid white;"></div>
                        <span>Dataset Center</span>
                    </div>
                `;
                return div;
            };
            legend.addTo(map);
            
            // Add click handler for facility placement
            map.on('click', function(e) {
                if (placementMode) {
                    placeMyFacility(e.latlng.lat, e.latlng.lng);
                }
            });
        }

        // Haversine formula for distance calculation
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 3959; // Earth's radius in miles
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                     Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                     Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        // Check if coordinates are within Permian Basin boundaries
        // Permian Basin roughly covers West Texas and SE New Mexico
        function isInPermianBasin(lat, lng) {
            // Permian Basin approximate boundaries:
            // Latitude: 30.5¬∞ to 33.5¬∞ N
            // Longitude: -105¬∞ to -100.5¬∞ W
            return lat >= 30.5 && lat <= 33.5 && lng >= -105 && lng <= -100.5;
        }

        // Load and parse Excel file with daily transaction data
        async function loadData(workbook, sheetName) {
            console.log('===== LOADDATA FUNCTION CALLED =====');
            console.log('Workbook:', workbook ? 'exists' : 'NULL');
            console.log('SheetName:', sheetName);
            console.log('Available sheets:', workbook ? workbook.SheetNames : 'N/A');
            
            document.getElementById('loading').classList.add('active');
            document.getElementById('loading').querySelector('.loading-text').textContent = 'Loading daily transaction data...';
            
            try {
                console.log('Step 1: Getting worksheet...');
                const worksheet = workbook.Sheets[sheetName];
                console.log('Worksheet exists:', worksheet ? 'YES' : 'NO');
                
                console.log('Step 2: Converting sheet to JSON...');
                const data = XLSX.utils.sheet_to_json(worksheet, { raw: false, dateNF: 'yyyy-mm-dd' });
                console.log('Data length:', data.length);
                console.log('First row sample:', data[0]);

                if (data.length === 0) {
                    throw new Error('No data found in spreadsheet');
                }

                // Store raw daily data
                badCoordinateRows = []; // Reset bad coordinates tracking
                
                rawDailyData = data.map((row, index) => {
                    // Parse date - handle both Date objects and strings
                    let parsedDate = null;
                    if (row['Date']) {
                        if (row['Date'] instanceof Date) {
                            parsedDate = row['Date'];
                        } else if (typeof row['Date'] === 'string') {
                            parsedDate = new Date(row['Date']);
                        } else if (typeof row['Date'] === 'number') {
                            // Excel serial date number
                            parsedDate = XLSX.SSF.parse_date_code(row['Date']);
                            if (parsedDate) {
                                parsedDate = new Date(parsedDate.y, parsedDate.m - 1, parsedDate.d);
                            }
                        }
                    }
                    
                    // Handle API # - check for "No API" entries
                    const apiValue = row['API #'] ? String(row['API #']) : '';
                    const isNoAPI = apiValue.toLowerCase().includes('no api') || !apiValue;
                    
                    // Get basin (Delaware or Midland) - NEW COLUMN!
                    const basin = row['Basin'] || 'Unknown';
                    
                    // Get coordinate source from Notes column
                    let coordSource = 'Unknown';
                    if (row['Notes']) {
                        const note = String(row['Notes']).trim();
                        if (note.includes('Good API')) {
                            coordSource = 'API Lookup';
                        } else if (note.includes('EA Data')) {
                            coordSource = 'EA Data';
                        } else if (note.includes('Indicated County')) {
                            coordSource = 'County Centroid';
                        } else if (note.includes('Landfill County')) {
                            coordSource = 'Landfill County';
                        }
                    }
                    
                    // Get coordinates - Data is pre-cleaned, all should be valid!
                    let lat = Number(parseFloat(row['Wellsite Lat']));
                    let lng = Number(parseFloat(row['Wellsite Long']));
                    
                    // Validate coordinates are numbers and in valid range
                    const hasValidCoords = !isNaN(lat) && !isNaN(lng) && 
                                          Math.abs(lat) >= 0.0001 && Math.abs(lng) >= 0.0001 &&
                                          lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180;
                    
                    // Only add rows with valid coordinates and quantities
                    if (!hasValidCoords) {
                        console.warn(`Row ${index + 2}: Invalid coordinates - lat=${lat}, lng=${lng}`);
                        return null;  // Skip this row - will be filtered out
                    }
                    
                    const processedRow = {
                        api: apiValue,
                        lease: row['Lease'] || '',
                        basin: basin,  // Track which basin (Delaware/Midland)
                        coordSource: coordSource,  // Track coordinate source method
                        lat: lat,
                        lng: lng,
                        destCompany: row['Destination Company'] || '',
                        destSite: row['Destination Site'] || '',
                        date: parsedDate,
                        quantity: parseFloat(row['Quantity']) || 0,
                        county: row['County'] || '',
                        generator: row['Generator'] || '',
                        transporter: row['Transporter'] || ''
                    };
                    
                    // DEBUG: Log first row to verify types
                    if (index === 0) {
                        console.log('=== FIRST ROW TYPE CHECK ===');
                        console.log('Basin:', processedRow.basin);
                        console.log('Coord Source:', processedRow.coordSource);
                        console.log('processedRow.lat:', processedRow.lat, 'type:', typeof processedRow.lat);
                        console.log('processedRow.lng:', processedRow.lng, 'type:', typeof processedRow.lng);
                        console.log('Is lat a number?', typeof processedRow.lat === 'number');
                        console.log('Is lng a number?', typeof processedRow.lng === 'number');
                    }
                    
                    
                    // Skip rows with invalid quantity
                    if (processedRow.quantity <= 0) {
                        return null;  // Will be filtered out
                    }
                    
                    return processedRow;
                }).filter(row => row != null);  // Remove skipped rows (both null and undefined)

                console.log(`=== DATA LOADED ===`);
                console.log(`Total rows processed: ${data.length}`);
                console.log(`Rows with valid data: ${rawDailyData.length}`);
                console.log(`Skipped rows: ${data.length - rawDailyData.length}`);

                if (rawDailyData.length === 0) {
                    throw new Error('No valid data rows found');
                }
                
                console.log('Sample dates from data:', rawDailyData.slice(0, 5).map(r => r.date));
                
                // Read landfill coordinates from Landfill Data sheet
                console.log('Step 4: Loading landfill data...');
                loadLandfillData(workbook);
                console.log('Landfill coordinates loaded:', Object.keys(landfillCoordinates).length, 'landfills');
                console.log('Landfill list:', Object.keys(landfillCoordinates));
                
                // Extract unique generators and transporters
                const generatorSet = new Set();
                const transporterSet = new Set();
                rawDailyData.forEach(row => {
                    if (row.generator) generatorSet.add(row.generator);
                    if (row.transporter) transporterSet.add(row.transporter);
                });
                generators = Array.from(generatorSet).sort();
                transporters = Array.from(transporterSet).sort();
                
                // SELECT ALL generators and transporters by default
                selectedGenerators = new Set(generators);
                selectedTransporters = new Set(transporters);
                
                console.log(`Found ${generators.length} unique generators and ${transporters.length} unique transporters`);
                console.log('All generators and transporters selected by default');
                
                // Read landfill coordinates from Landfill Data sheet
                loadLandfillData(workbook);

                // Calculate date range
                const dates = rawDailyData.filter(r => r.date && r.date instanceof Date && !isNaN(r.date)).map(r => r.date);
                
                if (dates.length === 0) {
                    throw new Error('No valid dates found in data');
                }
                
                minDate = new Date(Math.min(...dates));
                minDate.setHours(0, 0, 0, 0);
                
                maxDate = new Date(Math.max(...dates));
                maxDate.setHours(23, 59, 59, 999);
                
                console.log('Data date range:', minDate, 'to', maxDate);
                console.log('Total daily transactions loaded:', rawDailyData.length);
                
                // Set initial filter to full range
                filterStartDate = new Date(minDate);
                filterEndDate = new Date(maxDate);

                // Set up date inputs
                const minDateInput = new Date(minDate);
                minDateInput.setHours(0, 0, 0, 0);
                const maxDateInput = new Date(maxDate);
                maxDateInput.setHours(0, 0, 0, 0);
                
                document.getElementById('startDate').valueAsDate = minDateInput;
                document.getElementById('endDate').valueAsDate = maxDateInput;
                updateDateRangeDisplay();
                initializeDateSlider();

                // Aggregate data by well site
                aggregateWellData();

                // Calculate outlier count from COMPLETE dataset (before any filtering)
                try {
                    console.log('About to calculate total outliers...');
                    const centerpoint = calculateTotalOutliers();
                    
                    // Add centerpoint marker to map
                    if (centerpoint) {
                        addCenterpointMarker(centerpoint.lat, centerpoint.lng);
                    }
                    
                    // Calculate and add volume-weighted center marker
                    updateVolumeCenter();
                    
                    // Update the outlier count display immediately
                    const outlierElement = document.getElementById('outlierCount');
                    if (outlierElement) {
                        outlierElement.textContent = totalOutlierCount;
                        console.log(`Updated outlier display to: ${totalOutlierCount}`);
                    } else {
                        console.error('Could not find outlierCount element');
                    }
                } catch (error) {
                    console.error('Error calculating outliers:', error);
                    totalOutlierCount = 0;
                }

                // Now that datasetCenter is established, re-aggregate with distance filter applied
                aggregateWellData();

                // Extract unique landfills from aggregated data
                const landfillMap = new Map();
                console.log('Step 5: Extracting landfills from wellData...');
                console.log('wellData length:', wellData.length);
                console.log('First 3 wells:', wellData.slice(0, 3).map(w => ({ 
                    site: w.destSite, 
                    company: w.destCompany,
                    lat: w.landfillLat,
                    lng: w.landfillLng
                })));
                
                wellData.forEach(well => {
                    const key = `${well.destSite}-${well.destCompany}`;
                    if (!landfillMap.has(key) && well.landfillLat && well.landfillLng) {
                        landfillMap.set(key, {
                            site: well.destSite,
                            company: well.destCompany,
                            lat: well.landfillLat,
                            lng: well.landfillLng
                        });
                    }
                });
                landfills = Array.from(landfillMap.values());
                console.log('Extracted landfills from wellData:', landfills.length);
                console.log('Landfill sites:', landfills.map(l => l.site));

                renderLandfillList();
                renderGeneratorList();
                renderTransporterList();
                addWellMarkers();
                addLandfillMarkers();
                
                // Update filtered out count display
                updateFilteredOutCount();
                
                // Log and show bad coordinates button if any found
                if (badCoordinateRows.length > 0) {
                    console.warn(`Found ${badCoordinateRows.length} rows with invalid/missing coordinates`);
                    document.getElementById('badCoordsCount').textContent = badCoordinateRows.length;
                    document.getElementById('badCoordsExportBtn').style.display = 'block';
                } else {
                    console.log('All rows have valid coordinates ‚úì');
                    document.getElementById('badCoordsExportBtn').style.display = 'none';
                }
                
                document.getElementById('loading').classList.remove('active');
                document.getElementById('uploadSection').style.display = 'none';
                document.getElementById('sheetSelectionSection').style.display = 'none';
                
                // Show global filters and tabs
                document.getElementById('globalFiltersSection').style.display = 'block';
                document.getElementById('tabsContainer').style.display = 'block';
                
                document.getElementById('dateRangeSection').style.display = 'block';
                document.getElementById('permianBasinSection').style.display = 'block';
                document.getElementById('landfillSection').style.display = 'block';
                document.getElementById('generatorSection').style.display = 'block';
                document.getElementById('transporterSection').style.display = 'block';
                document.getElementById('radiusSection').style.display = 'block';
                document.getElementById('distanceFromCenterSection').style.display = 'block';
                document.getElementById('volumeCenterSection').style.display = 'block';
                document.getElementById('myFacilitySection').style.display = 'block';
                document.getElementById('statsPanel').style.display = 'block';
                document.getElementById('exportBtn').style.display = 'block';
                document.getElementById('resetBtn').style.display = 'block';
                document.getElementById('orlaExportBtn').style.display = 'block';
                
                // Initialize AI Analytics Assistant
                initializeAIAssistant();
                
                // Verify outlier count is displayed
                console.log('Stats panel now visible. Outlier count value:', document.getElementById('outlierCount').textContent);
                
                // Fit map to show all markers with valid coordinates
                if (wellData.length > 0) {
                    const validCoords = wellData
                        .filter(w => w.lat && w.lng && !isNaN(w.lat) && !isNaN(w.lng) && 
                                   Math.abs(w.lat) >= 0.0001 && Math.abs(w.lng) >= 0.0001)
                        .map(w => [w.lat, w.lng]);
                    
                    if (validCoords.length > 0) {
                        const bounds = L.latLngBounds(validCoords);
                        map.fitBounds(bounds, { padding: [50, 50] });
                        console.log(`Map fitted to ${validCoords.length} valid coordinates`);
                    } else {
                        console.error('No valid coordinates found in wellData');
                    }
                }
                
                console.log('===== LOADDATA COMPLETED SUCCESSFULLY =====');
                console.log('Final state:');
                console.log('  - rawDailyData:', rawDailyData.length, 'rows');
                console.log('  - wellData:', wellData.length, 'aggregated sources');
                console.log('  - landfills:', landfills.length, 'unique landfills');
                console.log('  - Date range:', minDate, 'to', maxDate);
                
            } catch (error) {
                console.error('===== LOADDATA FAILED =====');
                console.error('Error loading data:', error);
                console.error('Stack trace:', error.stack);
                alert('Error loading data file: ' + error.message + '\n\nPlease make sure the file contains a sheet with columns: API #, Lease, Wellsite Lat, Wellsite Long, Destination Company, Destination Site, Date, Quantity');
                document.getElementById('loading').classList.remove('active');
            }
        }

        // Landfill coordinates lookup (approximations for West Texas area)
        // Users can update these with exact coordinates if needed
        // Default landfill coordinates (from Landfill Data worksheet)
        const defaultLandfillCoordinates = {
            // Delaware Basin landfills
            'ORLA EWF': { lat: 31.865379, lng: -103.847547 },
            'RED BLUFF': { lat: 31.9861, lng: -104.021569 },
            'ORLA LANDFILL': { lat: 31.824627, lng: -103.910185 },
            'DEEP SIX': { lat: 31.286899, lng: -103.392814 },
            'REEVES': { lat: 31.654254, lng: -103.637612 },
            'DRF MENTONE': { lat: 31.960808, lng: -103.75866 },
            'PECOS': { lat: 31.320076, lng: -103.621133 },
            // Midland Basin landfills
            'UPTON': { lat: 31.499316, lng: -101.931524 },
            'STANTON LANDFILL': { lat: 31.981708, lng: -101.771822 },
            'WISHBONE': { lat: 32.201328, lng: -101.737306 },
            'SOUTH ODESSA': { lat: 31.77227, lng: -102.542218 },
            'REAGAN': { lat: 31.418575, lng: -101.691314 },
            'BIG LAKE': { lat: 31.344978, lng: -101.502558 },
            'HOWARD': { lat: 32.175082, lng: -101.665695 }
        };
        
        // County centroids from uploaded County Centroids sheet (287 counties)
        const countyCentroids = {
            'BERNALILLO': { lat: 35.0764, lng: -106.6003 },
            'CATRON': { lat: 33.7446, lng: -108.6163 },
            'CHAVES': { lat: 33.1029, lng: -104.6189 },
            'CIBOLA': { lat: 35.0684, lng: -108.0578 },
            'COLFAX': { lat: 36.5312, lng: -104.8761 },
            'CURRY': { lat: 34.5614, lng: -103.3435 },
            'DE BACA': { lat: 34.4355, lng: -104.3373 },
            'DONA ANA': { lat: 32.2645, lng: -106.7618 },
            'EDDY': { lat: 32.4813, lng: -104.3334 },
            'GRANT': { lat: 32.7929, lng: -108.1559 },
            'GUADALUPE': { lat: 34.796, lng: -104.6932 },
            'HARDING': { lat: 35.8378, lng: -103.9755 },
            'HIDALGO': { lat: 32.1413, lng: -108.753 },
            'LEA': { lat: 32.6832, lng: -103.2756 },
            'LINCOLN': { lat: 33.6404, lng: -105.654 },
            'LOS ALAMOS': { lat: 35.8495, lng: -106.288 },
            'LUNA': { lat: 32.1598, lng: -107.7115 },
            'MCKINLEY': { lat: 35.5227, lng: -108.4121 },
            'MORA': { lat: 35.9924, lng: -105.0612 },
            'OTERO': { lat: 32.918, lng: -105.7532 },
            'QUAY': { lat: 35.082, lng: -103.4518 },
            'RIO ARRIBA': { lat: 36.3827, lng: -106.4371 },
            'ROOSEVELT': { lat: 33.9134, lng: -103.3841 },
            'SAN JUAN': { lat: 36.7099, lng: -108.1436 },
            'SAN MIGUEL': { lat: 35.49, lng: -104.9301 },
            'SANDOVAL': { lat: 35.6305, lng: -106.6681 },
            'SANTA FE': { lat: 35.5557, lng: -105.9832 },
            'SIERRA': { lat: 33.0514, lng: -107.2479 },
            'SOCORRO': { lat: 34.2467, lng: -106.9141 },
            'TAOS': { lat: 36.3496, lng: -105.6691 },
            'TORRANCE': { lat: 34.7552, lng: -106.0166 },
            'UNION': { lat: 36.3814, lng: -103.457 },
            'VALENCIA': { lat: 34.734, lng: -106.7277 },
            'ANDERSON': { lat: 31.81321543, lng: -95.65251774 },
            'ANDREWS': { lat: 32.30506283, lng: -102.6378839 },
            'ANGELINA': { lat: 31.25475875, lng: -94.611742 },
            'ARANSAS': { lat: 28.12709562, lng: -96.99258951 },
            'ARCHER': { lat: 33.61539176, lng: -98.68783437 },
            'ARMSTRONG': { lat: 34.96522076, lng: -101.3572412 },
            'ATASCOSA': { lat: 28.89418432, lng: -98.52741302 },
            'AUSTIN': { lat: 29.88711223, lng: -96.27791829 },
            'BAILEY': { lat: 34.0684915, lng: -102.8299069 },
            'BANDERA': { lat: 29.74724753, lng: -99.24637282 },
            'BASTROP': { lat: 30.10353518, lng: -97.31187705 },
            'BAYLOR': { lat: 33.61648147, lng: -99.21351964 },
            'BEE': { lat: 28.41736675, lng: -97.74116811 },
            'BELL': { lat: 31.03778267, lng: -97.47790776 },
            'BEXAR': { lat: 29.44884523, lng: -98.51966309 },
            'BLANCO': { lat: 30.26636128, lng: -98.39974086 },
            'BORDEN': { lat: 32.7436916, lng: -101.4317533 },
            'BOSQUE': { lat: 31.90050476, lng: -97.63437613 },
            'BOWIE': { lat: 33.44572786, lng: -94.42324298 },
            'BRAZORIA': { lat: 29.19345387, lng: -95.45578479 },
            'BRAZOS': { lat: 30.6610425, lng: -96.3022943 },
            'BREWSTER': { lat: 29.81205836, lng: -103.2518906 },
            'BRISCOE': { lat: 34.53041048, lng: -101.2085769 },
            'BROOKS': { lat: 27.0315669, lng: -98.21874127 },
            'BROWN': { lat: 31.77432313, lng: -98.99989649 },
            'BURLESON': { lat: 30.49246139, lng: -96.62109399 },
            'BURNET': { lat: 30.78843382, lng: -98.18252382 },
            'CALDWELL': { lat: 29.83677935, lng: -97.61983479 },
            'CALHOUN': { lat: 28.48966896, lng: -96.64708119 },
            'CALLAHAN': { lat: 32.2977738, lng: -99.37359692 },
            'CAMERON': { lat: 26.13847728, lng: -97.51499968 },
            'CAMP': { lat: 32.97321771, lng: -94.97860185 },
            'CARSON': { lat: 35.40346802, lng: -101.3542037 },
            'CASS': { lat: 33.07750446, lng: -94.34348771 },
            'CASTRO': { lat: 34.53000304, lng: -102.2617608 },
            'CHAMBERS': { lat: 29.73912276, lng: -94.60891308 },
            'CHEROKEE': { lat: 31.83695632, lng: -95.16515234 },
            'CHILDRESS': { lat: 34.52929257, lng: -100.2075664 },
            'CLAY': { lat: 33.78379717, lng: -98.208958 },
            'COCHRAN': { lat: 33.60410808, lng: -102.8285264 },
            'COKE': { lat: 31.88849293, lng: -100.5298747 },
            'COLEMAN': { lat: 31.77329421, lng: -99.45362579 },
            'COLLIN': { lat: 33.18789055, lng: -96.57248871 },
            'COLLINGSWORTH': { lat: 34.96498493, lng: -100.2700733 },
            'COLORADO': { lat: 29.6208542, lng: -96.52630821 },
            'COMAL': { lat: 29.80816362, lng: -98.27814516 },
            'COMANCHE': { lat: 31.9490639, lng: -98.55841538 },
            'CONCHO': { lat: 31.32645211, lng: -99.86413426 },
            'COOKE': { lat: 33.638465, lng: -97.21247642 },
            'CORYELL': { lat: 31.39087578, lng: -97.7991883 },
            'COTTLE': { lat: 34.0776571, lng: -100.2786983 },
            'CRANE': { lat: 31.42846287, lng: -102.5156425 },
            'CROCKETT': { lat: 30.72291931, lng: -101.4118364 },
            'CROSBY': { lat: 33.61459873, lng: -101.2998612 },
            'CULBERSON': { lat: 31.44709817, lng: -104.5177421 },
            'DALLAM': { lat: 36.27777107, lng: -102.6021647 },
            'DALLAS': { lat: 32.76653746, lng: -96.77781862 },
            'DAWSON': { lat: 32.74258137, lng: -101.9476136 },
            'DE WITT': { lat: 29.08201599, lng: -97.35666976 },
            'DEAF SMITH': { lat: 34.96602014, lng: -102.6048162 },
            'DELTA': { lat: 33.38623601, lng: -95.67221685 },
            'DENTON': { lat: 33.205574, lng: -97.11681154 },
            'DICKENS': { lat: 33.61663428, lng: -100.7788138 },
            'DIMMIT': { lat: 28.42161168, lng: -99.760574 },
            'DONLEY': { lat: 34.96540246, lng: -100.8140501 },
            'DUVAL': { lat: 27.68133382, lng: -98.50889672 },
            'EASTLAND': { lat: 32.32739258, lng: -98.8325713 },
            'ECTOR': { lat: 31.86908156, lng: -102.5430907 },
            'EDWARDS': { lat: 29.98248216, lng: -100.3048937 },
            'EL PASO': { lat: 31.7686226, lng: -106.2352229 },
            'ELLIS': { lat: 32.34839264, lng: -96.79467417 },
            'ERATH': { lat: 32.23640361, lng: -98.21722756 },
            'FALLS': { lat: 31.25317017, lng: -96.93579511 },
            'FANNIN': { lat: 33.59396919, lng: -96.10656755 },
            'FAYETTE': { lat: 29.87683207, lng: -96.91968047 },
            'FISHER': { lat: 32.74305155, lng: -100.4019503 },
            'FLOYD': { lat: 34.07239775, lng: -101.3033037 },
            'FOARD': { lat: 33.97408519, lng: -99.77871109 },
            'FORT BEND': { lat: 29.52763253, lng: -95.77090562 },
            'FRANKLIN': { lat: 33.17550691, lng: -95.21841437 },
            'FREESTONE': { lat: 31.70486443, lng: -96.14918535 },
            'FRIO': { lat: 28.86726774, lng: -99.10826004 },
            'GAINES': { lat: 32.74074537, lng: -102.6351246 },
            'GALVESTON': { lat: 29.39424415, lng: -94.96474975 },
            'GARZA': { lat: 33.17991074, lng: -101.2984496 },
            'GILLESPIE': { lat: 30.31800246, lng: -98.94627245 },
            'GLASSCOCK': { lat: 31.8694238, lng: -101.520742 },
            'GOLIAD': { lat: 28.65708563, lng: -97.42646082 },
            'GONZALES': { lat: 29.45641495, lng: -97.49279927 },
            'GRAY': { lat: 35.40130666, lng: -100.812475 },
            'GRAYSON': { lat: 33.62684371, lng: -96.67764864 },
            'GREGG': { lat: 32.48036452, lng: -94.81723694 },
            'GRIMES': { lat: 30.54360689, lng: -95.98557334 },
            'HALE': { lat: 34.07051782, lng: -101.8269082 },
            'HALL': { lat: 34.53074134, lng: -100.6809876 },
            'HAMILTON': { lat: 31.70479181, lng: -98.11066654 },
            'HANSFORD': { lat: 36.27753179, lng: -101.3545624 },
            'HARDEMAN': { lat: 34.28865227, lng: -99.7453851 },
            'HARDIN': { lat: 30.33238431, lng: -94.39021394 },
            'HARRIS': { lat: 29.85967144, lng: -95.39782106 },
            'HARRISON': { lat: 32.54814898, lng: -94.37155736 },
            'HARTLEY': { lat: 35.83996755, lng: -102.6028835 },
            'HASKELL': { lat: 33.17824805, lng: -99.73029401 },
            'HAYS': { lat: 30.05782657, lng: -98.03104087 },
            'HEMPHILL': { lat: 35.83750155, lng: -100.2704628 },
            'HENDERSON': { lat: 32.21188078, lng: -95.85356847 },
            'HILL': { lat: 31.99079033, lng: -97.1324142 },
            'HOCKLEY': { lat: 33.60750375, lng: -102.3430919 },
            'HOOD': { lat: 32.43107878, lng: -97.83280338 },
            'HOPKINS': { lat: 33.14933822, lng: -95.56414173 },
            'HOUSTON': { lat: 31.31764137, lng: -95.42225367 },
            'HOWARD': { lat: 32.30610232, lng: -101.4355097 },
            'HUDSPETH': { lat: 31.45613738, lng: -105.3869428 },
            'HUNT': { lat: 33.123531, lng: -96.08550014 },
            'HUTCHINSON': { lat: 35.84000866, lng: -101.3547257 },
            'IRION': { lat: 31.30393203, lng: -100.9824126 },
            'JACK': { lat: 33.23345819, lng: -98.1725509 },
            'JACKSON': { lat: 28.95603133, lng: -96.57883268 },
            'JASPER': { lat: 30.74391255, lng: -94.02495849 },
            'JEFF DAVIS': { lat: 30.71559322, lng: -104.1403539 },
            'JEFFERSON': { lat: 29.88425832, lng: -94.1708778 },
            'JIM HOGG': { lat: 27.04340499, lng: -98.6972921 },
            'JIM WELLS': { lat: 27.73131099, lng: -98.0898649 },
            'JOHNSON': { lat: 32.37899918, lng: -97.36660504 },
            'JONES': { lat: 32.73970429, lng: -99.87850599 },
            'KARNES': { lat: 28.90493782, lng: -97.85960621 },
            'KAUFMAN': { lat: 32.59927808, lng: -96.28779341 },
            'KENDALL': { lat: 29.9446397, lng: -98.71160511 },
            'KENEDY': { lat: 26.92409448, lng: -97.68137783 },
            'KENT': { lat: 33.18284492, lng: -100.7791031 },
            'KERR': { lat: 30.06153035, lng: -99.35016969 },
            'KIMBLE': { lat: 30.48676251, lng: -99.74892716 },
            'KING': { lat: 33.61641863, lng: -100.2558584 },
            'KINNEY': { lat: 29.35000302, lng: -100.4178441 },
            'KLEBERG': { lat: 27.43274395, lng: -97.72889778 },
            'KNOX': { lat: 33.60614755, lng: -99.74144313 },
            'LA SALLE': { lat: 28.34621032, lng: -99.1034773 },
            'LAMAR': { lat: 33.66746186, lng: -95.57110784 },
            'LAMB': { lat: 34.06861242, lng: -102.3517095 },
            'LAMPASAS': { lat: 31.19627791, lng: -98.24142711 },
            'LAVACA': { lat: 29.38437003, lng: -96.93020993 },
            'LEE': { lat: 30.31065065, lng: -96.96568735 },
            'LEON': { lat: 31.29655719, lng: -95.99554292 },
            'LIBERTY': { lat: 30.15153187, lng: -94.8120925 },
            'LIMESTONE': { lat: 31.54541898, lng: -96.58056718 },
            'LIPSCOMB': { lat: 36.27778432, lng: -100.27317 },
            'LIVE OAK': { lat: 28.3514375, lng: -98.12474493 },
            'LLANO': { lat: 30.70566579, lng: -98.68387398 },
            'LOVING': { lat: 31.84912973, lng: -103.5799063 },
            'LUBBOCK': { lat: 33.6101944, lng: -101.8205745 },
            'LYNN': { lat: 33.17685487, lng: -101.8160235 },
            'MADISON': { lat: 30.96564645, lng: -95.92818441 },
            'MARION': { lat: 32.79797929, lng: -94.35725239 },
            'MARTIN': { lat: 32.30605847, lng: -101.9512464 },
            'MASON': { lat: 30.71742293, lng: -99.2263026 },
            'MATAGORDA': { lat: 28.86711039, lng: -95.98533866 },
            'MAVERICK': { lat: 28.74260943, lng: -100.3144638 },
            'MCCULLOCH': { lat: 31.19896752, lng: -99.34754972 },
            'MCLENNAN': { lat: 31.55234489, lng: -97.20184883 },
            'MCMULLEN': { lat: 28.35351091, lng: -98.56842256 },
            'MEDINA': { lat: 29.35520493, lng: -99.11008331 },
            'MENARD': { lat: 30.88981785, lng: -99.82061472 },
            'MIDLAND': { lat: 31.86921148, lng: -102.0315032 },
            'MILAM': { lat: 30.78625299, lng: -96.97683495 },
            'MILLS': { lat: 31.49524259, lng: -98.59552736 },
            'MITCHELL': { lat: 32.30636024, lng: -100.9211128 },
            'MONTAGUE': { lat: 33.67496328, lng: -97.72466993 },
            'MONTGOMERY': { lat: 30.30022409, lng: -95.50301411 },
            'MOORE': { lat: 35.83768863, lng: -101.8929556 },
            'MORRIS': { lat: 33.11368507, lng: -94.73205137 },
            'MOTLEY': { lat: 34.07409017, lng: -100.7798961 },
            'NACOGDOCHES': { lat: 31.61604108, lng: -94.6158776 },
            'NAVARRO': { lat: 32.04695429, lng: -96.47248134 },
            'NEWTON': { lat: 30.78619977, lng: -93.74462993 },
            'NOLAN': { lat: 32.3034718, lng: -100.4060989 },
            'NUECES': { lat: 27.72621549, lng: -97.61767326 },
            'OCHILTREE': { lat: 36.27846334, lng: -100.815653 },
            'OLDHAM': { lat: 35.40497586, lng: -102.6029949 },
            'ORANGE': { lat: 30.12807126, lng: -93.89653794 },
            'PALO PINTO': { lat: 32.75316856, lng: -98.31299522 },
            'PANOLA': { lat: 32.16222886, lng: -94.30552858 },
            'PARKER': { lat: 32.77852261, lng: -97.80472194 },
            'PARMER': { lat: 34.53014507, lng: -102.784594 },
            'PECOS': { lat: 30.78100044, lng: -102.7235743 },
            'POLK': { lat: 30.79250963, lng: -94.82994949 },
            'POTTER': { lat: 35.40128927, lng: -101.8940484 },
            'PRESIDIO': { lat: 29.99977786, lng: -104.2405552 },
            'RAINS': { lat: 32.87004212, lng: -95.79347545 },
            'RANDALL': { lat: 34.96594288, lng: -101.8968527 },
            'REAGAN': { lat: 31.36617698, lng: -101.5230108 },
            'REAL': { lat: 29.83182711, lng: -99.82215881 },
            'RED RIVER': { lat: 33.62074539, lng: -95.0501886 },
            'REEVES': { lat: 31.32307061, lng: -103.693143 },
            'REFUGIO': { lat: 28.32681413, lng: -97.16546961 },
            'ROBERTS': { lat: 35.8385577, lng: -100.8135689 },
            'ROBERTSON': { lat: 31.02705415, lng: -96.51272568 },
            'ROCKWALL': { lat: 32.89786769, lng: -96.40780584 },
            'RUNNELS': { lat: 31.83105393, lng: -99.97624799 },
            'RUSK': { lat: 32.10803224, lng: -94.76169577 },
            'SABINE': { lat: 31.34321941, lng: -93.85170439 },
            'SAN AUGUSTINE': { lat: 31.39427005, lng: -94.16809762 },
            'SAN JACINTO': { lat: 30.57948905, lng: -95.16683273 },
            'SAN PATRICIO': { lat: 28.00922186, lng: -97.51859857 },
            'SAN SABA': { lat: 31.15520543, lng: -98.81754295 },
            'SCHLEICHER': { lat: 30.89661056, lng: -100.538097 },
            'SCURRY': { lat: 32.74720063, lng: -100.9165071 },
            'SHACKELFORD': { lat: 32.7360276, lng: -99.35403034 },
            'SHELBY': { lat: 31.79242191, lng: -94.14495261 },
            'SHERMAN': { lat: 36.27765824, lng: -101.8933822 },
            'SMITH': { lat: 32.37514553, lng: -95.26909511 },
            'SOMERVELL': { lat: 32.22229511, lng: -97.77456553 },
            'STARR': { lat: 26.56212627, lng: -98.73834895 },
            'STEPHENS': { lat: 32.73584155, lng: -98.83612016 },
            'STERLING': { lat: 31.82786516, lng: -101.0500699 },
            'STONEWALL': { lat: 33.17842158, lng: -100.255259 },
            'SUTTON': { lat: 30.49747152, lng: -100.5382263 },
            'SWISHER': { lat: 34.53064989, lng: -101.734951 },
            'TARRANT': { lat: 32.77185236, lng: -97.29116473 },
            'TAYLOR': { lat: 32.30138229, lng: -99.89003941 },
            'TERRELL': { lat: 30.22502597, lng: -102.0764533 },
            'TERRY': { lat: 33.17373729, lng: -102.335157 },
            'THROCKMORTON': { lat: 33.17753907, lng: -99.21236832 },
            'TITUS': { lat: 33.2160906, lng: -94.96509786 },
            'TOM GREEN': { lat: 31.4044442, lng: -100.4620678 },
            'TRAVIS': { lat: 30.33423319, lng: -97.78194654 },
            'TRINITY': { lat: 31.0885069, lng: -95.13551682 },
            'TYLER': { lat: 30.7712607, lng: -94.37651432 },
            'UPSHUR': { lat: 32.7362827, lng: -94.94132011 },
            'UPTON': { lat: 31.36853957, lng: -102.0430005 },
            'UVALDE': { lat: 29.35669829, lng: -99.76203107 },
            'VAL VERDE': { lat: 29.89300587, lng: -101.15171 },
            'VAN ZANDT': { lat: 32.56368961, lng: -95.8364862 },
            'VICTORIA': { lat: 28.79640594, lng: -96.97176602 },
            'WALKER': { lat: 30.73899492, lng: -95.57224172 },
            'WALLER': { lat: 30.01093722, lng: -95.98768942 },
            'WARD': { lat: 31.509424, lng: -103.1024636 },
            'WASHINGTON': { lat: 30.2145299, lng: -96.40356575 },
            'WEBB': { lat: 27.76102524, lng: -99.33170164 },
            'WHARTON': { lat: 29.2778362, lng: -96.22197375 },
            'WHEELER': { lat: 35.40129002, lng: -100.2697634 },
            'WICHITA': { lat: 33.98421585, lng: -98.70153389 },
            'WILBARGER': { lat: 34.08044953, lng: -99.24089568 },
            'WILLACY': { lat: 26.47132899, lng: -97.64303323 },
            'WILLIAMSON': { lat: 30.64834941, lng: -97.60105467 },
            'WILSON': { lat: 29.17315896, lng: -98.08621015 },
            'WINKLER': { lat: 31.85008609, lng: -103.0484794 },
            'WISE': { lat: 33.21585061, lng: -97.65444124 },
            'WOOD': { lat: 32.78634374, lng: -95.38206498 },
            'YOAKUM': { lat: 33.17293501, lng: -102.8278792 },
            'YOUNG': { lat: 33.17670764, lng: -98.68781396 },
            'ZAPATA': { lat: 27.00089072, lng: -99.16860134 },
            'ZAVALA': { lat: 28.86530621, lng: -99.76102001 }
        };
        
        let landfillCoordinates = {};
        
        // Map landfill sites to their counties (for fallback when no GPS and no source county)
        const landfillToCounty = {
            // Delaware Basin landfills
            'ORLA EWF': 'REEVES',
            'ORLA LANDFILL': 'REEVES',
            'REEVES': 'REEVES',
            'RED BLUFF': 'REEVES',
            'DEEP SIX': 'WARD',
            'PECOS': 'PECOS',
            'DRF MENTONE': 'LOVING',
            // Midland Basin landfills
            'UPTON': 'UPTON',
            'STANTON LANDFILL': 'MARTIN',
            'WISHBONE': 'MARTIN',
            'SOUTH ODESSA': 'ECTOR',
            'REAGAN': 'REAGAN',
            'BIG LAKE': 'REAGAN',
            'HOWARD': 'HOWARD'
        };
        
        let generators = [];
        let transporters = [];
        let selectedGenerators = new Set();
        let selectedTransporters = new Set();
        
        // Date slider variables
        let sliderStartValue = 0;
        let sliderEndValue = 100;
        let totalDays = 0;

        // Initialize date slider
        function initializeDateSlider() {
            totalDays = Math.ceil((maxDate - minDate) / (1000 * 60 * 60 * 24));
            
            document.getElementById('dataMinDate').textContent = minDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
            document.getElementById('dataMaxDate').textContent = maxDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
            
            // Set sliders to full range (0 to 100)
            sliderStartValue = 0;
            sliderEndValue = 100;
            document.getElementById('dateSliderStart').value = 0;
            document.getElementById('dateSliderEnd').value = 100;
            
            updateSliderVisuals();
            updateDatesFromSlider(); // Sync text dates with slider
        }

        // Update slider visual range
        function updateSliderVisuals() {
            const rangeElement = document.getElementById('sliderRange');
            const minPercent = Math.min(sliderStartValue, sliderEndValue);
            const maxPercent = Math.max(sliderStartValue, sliderEndValue);
            
            rangeElement.style.left = minPercent + '%';
            rangeElement.style.width = (maxPercent - minPercent) + '%';
        }

        // Convert slider value to date
        function sliderValueToDate(value) {
            const dayOffset = Math.round((value / 100) * totalDays);
            const date = new Date(minDate);
            date.setDate(date.getDate() + dayOffset);
            return date;
        }

        // Convert date to slider value
        function dateToSliderValue(date) {
            const dayDiff = Math.ceil((date - minDate) / (1000 * 60 * 60 * 24));
            return Math.max(0, Math.min(100, (dayDiff / totalDays) * 100));
        }

        // Update date displays from slider
        function updateDatesFromSlider() {
            const startDate = sliderValueToDate(sliderStartValue);
            const endDate = sliderValueToDate(sliderEndValue);
            
            document.getElementById('sliderStartDate').textContent = startDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
            document.getElementById('sliderEndDate').textContent = endDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
            
            // Update the manual date inputs
            const startInput = new Date(startDate);
            startInput.setHours(0, 0, 0, 0);
            const endInput = new Date(endDate);
            endInput.setHours(0, 0, 0, 0);
            
            document.getElementById('startDate').valueAsDate = startInput;
            document.getElementById('endDate').valueAsDate = endInput;
            
            updateSliderVisuals();
        }

        // Update slider from manual date inputs
        function updateSliderFromDates() {
            const startInput = document.getElementById('startDate').value;
            const endInput = document.getElementById('endDate').value;
            
            if (startInput && endInput) {
                const startDate = new Date(startInput);
                const endDate = new Date(endInput);
                
                sliderStartValue = dateToSliderValue(startDate);
                sliderEndValue = dateToSliderValue(endDate);
                
                document.getElementById('dateSliderStart').value = sliderStartValue;
                document.getElementById('dateSliderEnd').value = sliderEndValue;
                
                updateDatesFromSlider();
            }
        }
        
        // Load landfill coordinates from Landfill Data worksheet
        function loadLandfillData(workbook) {
            // Start with defaults
            landfillCoordinates = { ...defaultLandfillCoordinates };
            
            try {
                // Check if Landfill Data sheet exists
                if (workbook.SheetNames.includes('Landfill Data')) {
                    const landfillSheet = workbook.Sheets['Landfill Data'];
                    const landfillData = XLSX.utils.sheet_to_json(landfillSheet);
                    
                    // Parse landfill coordinates
                    landfillData.forEach(row => {
                        const site = row['Destination Site'];
                        
                        // Handle different column name variations
                        let lat = row['Landfill Lat'] || row['Lat'] || row['Latitude'];
                        let lng = row['Landfill Long'] || row['Long'] || row['Longitude'];
                        
                        // Parse coordinates - handle degree symbol and convert to numbers
                        if (typeof lat === 'string') {
                            lat = Number(parseFloat(lat.replace('¬∞', '').trim()));
                        } else {
                            lat = Number(lat);
                        }
                        if (typeof lng === 'string') {
                            lng = Number(parseFloat(lng.replace('¬∞', '').trim()));
                        } else {
                            lng = Number(lng);
                        }
                        
                        if (site && !isNaN(lat) && !isNaN(lng)) {
                            landfillCoordinates[site] = { lat: lat, lng: lng };
                        }
                    });
                    
                    console.log('Loaded landfill coordinates from Landfill Data sheet:', landfillCoordinates);
                } else {
                    console.warn('Landfill Data sheet not found, using default coordinates');
                }
            } catch (error) {
                console.error('Error loading landfill data:', error);
                console.log('Using default landfill coordinates');
            }
        }

        // Aggregate daily transactions by well site
        function aggregateWellData() {
            document.getElementById('loading').querySelector('.loading-text').textContent = 'Aggregating well site data...';
            
            console.log('Aggregating data with filter:', filterStartDate, 'to', filterEndDate);
            
            // Filter data by date range
            let filteredDaily = rawDailyData.filter(row => {
                if (!row.date) return false;
                return row.date >= filterStartDate && row.date <= filterEndDate;
            });
            
            // Filter by selected generators if any
            if (selectedGenerators.size > 0) {
                filteredDaily = filteredDaily.filter(row => selectedGenerators.has(row.generator));
            }
            
            // Filter by selected transporters if any
            if (selectedTransporters.size > 0) {
                filteredDaily = filteredDaily.filter(row => selectedTransporters.has(row.transporter));
            }
            
            // Filter by Permian Basin boundaries if enabled
            let permianFilteredCount = 0;
            let permianFilteredVolume = 0;
            if (permianBasinOnly) {
                const beforePermianFilter = filteredDaily.length;
                filteredDaily = filteredDaily.filter(row => {
                    const inBasin = isInPermianBasin(row.lat, row.lng);
                    if (!inBasin) {
                        permianFilteredCount++;
                        permianFilteredVolume += row.quantity;
                    }
                    return inBasin;
                });
                console.log(`Permian Basin filter: ${filteredDaily.length} wells in basin, ${permianFilteredCount} filtered out`);
            }
            
            // Update Permian Basin filter stats
            document.getElementById('permianFilteredCount').textContent = formatNumber(permianFilteredCount);
            document.getElementById('permianFilteredVolume').textContent = formatNumber(permianFilteredVolume, 2);
            
            console.log(`Filtered ${filteredDaily.length} transactions from ${rawDailyData.length} total`);

            // Group by GPS Location, Destination Site, Generator, AND Transporter
            // This allows tracking soil movement regardless of API availability
            const aggregated = new Map();
            let skippedNoCoords = 0;
            
            filteredDaily.forEach(row => {
                // Skip rows without valid GPS coordinates (including zeros)
                if (!row.lat || !row.lng || isNaN(row.lat) || isNaN(row.lng) || 
                    Math.abs(row.lat) < 0.0001 || Math.abs(row.lng) < 0.0001) {
                    skippedNoCoords++;
                    return;
                }
                
                // Create key based on GPS coordinates (rounded to 4 decimals ~11 meters)
                // Plus destination, generator, and transporter
                const latKey = row.lat.toFixed(4);
                const lngKey = row.lng.toFixed(4);
                const key = `GPS:${latKey},${lngKey}-${row.destSite}-${row.generator}-${row.transporter}`;
                
                if (!aggregated.has(key)) {
                    // Get landfill coordinates from lookup table
                    const landfillCoords = landfillCoordinates[row.destSite] || { lat: null, lng: null };
                    
                    aggregated.set(key, {
                        api: row.api || 'N/A',
                        lease: row.lease,
                        basin: row.basin || 'Unknown',  // Track which basin (Delaware or Midland)
                        coordSource: row.coordSource || 'Unknown',  // Track coordinate source method
                        lat: Number(row.lat),  // Ensure number type
                        lng: Number(row.lng),  // Ensure number type
                        destCompany: row.destCompany,
                        destSite: row.destSite,
                        generator: row.generator,
                        transporter: row.transporter,
                        quantity: 0,
                        loadCount: 0,
                        firstDate: row.date,
                        lastDate: row.date,
                        landfillLat: Number(landfillCoords.lat),  // Ensure number type
                        landfillLng: Number(landfillCoords.lng)   // Ensure number type
                    });
                }
                
                const agg = aggregated.get(key);
                agg.quantity += row.quantity;
                agg.loadCount += 1;
                if (row.date < agg.firstDate) agg.firstDate = row.date;
                if (row.date > agg.lastDate) agg.lastDate = row.date;
            });

            // Convert to array
            wellData = Array.from(aggregated.values());
            
            console.log(`Aggregated ${filteredDaily.length - skippedNoCoords} daily transactions into ${wellData.length} unique soil sources`);
            if (skippedNoCoords > 0) {
                console.warn(`Skipped ${skippedNoCoords} transactions due to missing GPS coordinates`);
            }
            console.log(`Aggregation method: GPS location + Destination + Generator + Transporter`);
            
            // Apply distance from center filter if datasetCenter exists
            if (datasetCenter && maxDistanceFromCenter < 1000) {
                filteredWellData = wellData.filter(well => {
                    const distanceFromCenter = calculateDistance(
                        datasetCenter.lat, datasetCenter.lng,
                        well.lat, well.lng
                    );
                    return distanceFromCenter <= maxDistanceFromCenter;
                });
                console.log(`Distance filter: ${filteredWellData.length} wells within ${maxDistanceFromCenter} miles of center (from ${wellData.length} total)`);
            } else {
                filteredWellData = [...wellData];
            }

            console.log(`Aggregated ${filteredDaily.length} daily transactions into ${wellData.length} well site records`);
        }

        // Calculate total outliers from COMPLETE dataset (>100 miles from center)
        function calculateTotalOutliers() {
            console.log('=== calculateTotalOutliers called ===');
            console.log('wellData length:', wellData ? wellData.length : 'undefined');
            
            if (!wellData || wellData.length === 0) {
                console.warn('No wellData available for outlier calculation');
                totalOutlierCount = 0;
                return;
            }

            // Calculate centerpoint of ALL wells in dataset
            let sumLat = 0;
            let sumLng = 0;
            let invalidCoords = 0;
            let sampleWells = [];
            
            wellData.forEach((well, index) => {
                // Store first 5 wells for debugging
                if (index < 5) {
                    sampleWells.push({
                        lat: well.lat,
                        lng: well.lng,
                        latType: typeof well.lat,
                        lngType: typeof well.lng
                    });
                }
                
                // Log first 3 wells being summed
                if (index < 3) {
                    console.log(`Well ${index}: lat=${well.lat} (${typeof well.lat}), lng=${well.lng} (${typeof well.lng})`);
                }
                
                // Convert to number explicitly to avoid string concatenation
                const lat = Number(well.lat);
                const lng = Number(well.lng);
                
                // Log conversion for first 3 wells
                if (index < 3) {
                    console.log(`  After Number(): lat=${lat}, lng=${lng}`);
                    console.log(`  Adding to sums: sumLat was ${sumLat.toFixed(2)}, sumLng was ${sumLng.toFixed(2)}`);
                }
                
                if (isNaN(lat) || isNaN(lng)) {
                    invalidCoords++;
                    console.warn(`Invalid coordinates at index ${index}:`, well);
                } else {
                    sumLat += lat;
                    sumLng += lng;
                    
                    // Log sums after first 3 wells
                    if (index < 3) {
                        console.log(`  After adding: sumLat=${sumLat.toFixed(2)}, sumLng=${sumLng.toFixed(2)}`);
                    }
                }
            });
            
            console.log('First 5 wells for debugging:', sampleWells);
            console.log('First well as JSON:', JSON.stringify(sampleWells[0], null, 2));
            console.log(`Sum before division: lat=${sumLat.toFixed(2)}, lng=${sumLng.toFixed(2)}`);
            console.log(`Invalid coordinates skipped: ${invalidCoords}`);
            
            const validCount = wellData.length - invalidCoords;
            const centerLat = sumLat / validCount;
            const centerLng = sumLng / validCount;

            console.log(`Dataset centerpoint (all ${wellData.length} wells): ${centerLat.toFixed(6)}, ${centerLng.toFixed(6)}`);
            console.log(`Expected for Delaware Basin: lat ~32, lng ~-103`);

            // Count wells >100 miles from center
            let count = 0;
            wellData.forEach(well => {
                const distance = calculateDistance(centerLat, centerLng, well.lat, well.lng);
                if (distance > 100) {
                    count++;
                }
            });

            totalOutlierCount = count;
            console.log(`Total outliers (>100mi from center): ${totalOutlierCount} out of ${wellData.length} wells`);
            
            // Save dataset center in global variable for distance filtering
            datasetCenter = { lat: centerLat, lng: centerLng };
            
            // Return centerpoint coordinates for map marker
            return { lat: centerLat, lng: centerLng };
        }

        // Add centerpoint marker to map
        function addCenterpointMarker(lat, lng) {
            // Remove existing centerpoint marker if any
            if (centerpointMarker) {
                map.removeLayer(centerpointMarker);
            }
            
            // Create custom icon for centerpoint (bright green)
            const centerpointIcon = L.divIcon({
                className: 'centerpoint-marker',
                html: '<div style="background: #00ff00; width: 16px; height: 16px; border-radius: 50%; border: 3px solid white; box-shadow: 0 0 10px rgba(0,0,0,0.5);"></div>',
                iconSize: [16, 16],
                iconAnchor: [8, 8]
            });
            
            // Add marker to map
            centerpointMarker = L.marker([lat, lng], { 
                icon: centerpointIcon,
                zIndexOffset: 1000 // Ensure it's on top
            }).addTo(map);
            
            // Add popup
            centerpointMarker.bindPopup(`
                <strong>Dataset Centerpoint</strong><br>
                Lat: ${lat.toFixed(6)}<br>
                Lng: ${lng.toFixed(6)}<br>
                <em>Geographic center of all ${wellData.length} wells</em>
            `);
            
            console.log(`Added centerpoint marker at ${lat.toFixed(6)}, ${lng.toFixed(6)}`);
        }

        // Calculate volume-weighted center (strategic facility placement location)
        // Uses FILTERED data so it updates with date range
        function calculateVolumeCenter() {
            console.log('=== calculateVolumeCenter called ===');
            
            if (!filteredWellData || filteredWellData.length === 0) {
                console.warn('No filteredWellData available for volume center calculation');
                return null;
            }

            // Calculate volume-weighted centerpoint
            let totalVolume = 0;
            let weightedLat = 0;
            let weightedLng = 0;
            
            filteredWellData.forEach(well => {
                // Ensure coordinates and volume are numbers
                const lat = Number(well.lat);
                const lng = Number(well.lng);
                const volume = Number(well.quantity) || 0;
                
                if (!isNaN(lat) && !isNaN(lng) && volume > 0) {
                    totalVolume += volume;
                    weightedLat += lat * volume;
                    weightedLng += lng * volume;
                }
            });

            if (totalVolume === 0) {
                console.warn('Total volume is zero, cannot calculate volume center');
                return null;
            }

            const centerLat = weightedLat / totalVolume;
            const centerLng = weightedLng / totalVolume;

            console.log(`Volume-weighted center (${filteredWellData.length} wells, ${totalVolume.toFixed(2)} CY): ${centerLat.toFixed(6)}, ${centerLng.toFixed(6)}`);
            
            return { 
                lat: centerLat, 
                lng: centerLng,
                totalVolume: totalVolume,
                wellCount: filteredWellData.length
            };
        }

        // Add volume center marker to map
        function addVolumeCenterMarker(lat, lng, totalVolume, wellCount) {
            // Remove existing volume center marker if any
            if (volumeCenterMarker) {
                map.removeLayer(volumeCenterMarker);
            }
            
            // Create custom icon for volume center (purple)
            const volumeCenterIcon = L.divIcon({
                className: 'volume-center-marker',
                html: '<div style="background: #9b59b6; width: 18px; height: 18px; border-radius: 50%; border: 3px solid white; box-shadow: 0 0 10px rgba(0,0,0,0.5);"></div>',
                iconSize: [18, 18],
                iconAnchor: [9, 9]
            });
            
            // Add marker to map
            volumeCenterMarker = L.marker([lat, lng], { 
                icon: volumeCenterIcon,
                zIndexOffset: 1001 // Ensure it's on top of regular centerpoint
            }).addTo(map);
            
            // Add popup
            volumeCenterMarker.bindPopup(`
                <strong>Volume-Weighted Center</strong><br>
                <em>Optimal Facility Location</em><br><br>
                Lat: ${lat.toFixed(6)}<br>
                Lng: ${lng.toFixed(6)}<br>
                <br>
                Based on ${wellCount} wells<br>
                Total Volume: ${formatNumber(totalVolume, 2)} CY
            `);
            
            // Update display in control panel
            document.getElementById('volumeCenterCoords').textContent = 
                `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
            document.getElementById('volumeCenterTotal').textContent = 
                formatNumber(totalVolume, 2);
            
            console.log(`Added volume center marker at ${lat.toFixed(6)}, ${lng.toFixed(6)}`);
        }

        // Update volume center based on current filtered data
        function updateVolumeCenter() {
            const volumeCenter = calculateVolumeCenter();
            if (volumeCenter) {
                addVolumeCenterMarker(
                    volumeCenter.lat, 
                    volumeCenter.lng,
                    volumeCenter.totalVolume,
                    volumeCenter.wellCount
                );
            }
        }

        // ========== MY FACILITY ANALYZER ==========
        
        // Enable facility placement mode
        function enableFacilityPlacement() {
            placementMode = true;
            document.getElementById('facilityPlacementMode').style.display = 'block';
            document.getElementById('placeFacilityBtn').style.display = 'none';
            map.getContainer().style.cursor = 'crosshair';
        }
        
        // Disable facility placement mode
        function disableFacilityPlacement() {
            placementMode = false;
            document.getElementById('facilityPlacementMode').style.display = 'none';
            document.getElementById('placeFacilityBtn').style.display = 'block';
            map.getContainer().style.cursor = '';
        }
        
        // Place user's facility on map
        function placeMyFacility(lat, lng) {
            console.log(`Placing facility at: ${lat}, ${lng}`);
            
            myFacilityLocation = { lat, lng };
            
            // Remove existing marker if any
            if (myFacilityMarker) {
                map.removeLayer(myFacilityMarker);
            }
            if (myFacilityCircle) {
                map.removeLayer(myFacilityCircle);
            }
            
            // Create custom icon for facility (cyan/teal with dollar sign)
            const facilityIcon = L.divIcon({
                className: 'my-facility-marker',
                html: '<div style="background: #00d4ff; width: 24px; height: 24px; border-radius: 50%; border: 4px solid white; box-shadow: 0 0 15px rgba(0,212,255,0.8); display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: bold; color: #003d4d;">$</div>',
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            });
            
            // Add marker
            myFacilityMarker = L.marker([lat, lng], { 
                icon: facilityIcon,
                zIndexOffset: 2000 // Ensure it's on top
            }).addTo(map);
            
            // Add popup
            myFacilityMarker.bindPopup(`
                <strong style="color: #00d4ff;">MY FACILITY</strong><br>
                <em>Proposed Location</em><br><br>
                Lat: ${lat.toFixed(6)}<br>
                Lng: ${lng.toFixed(6)}
            `);
            
            // Draw service radius circle
            myFacilityCircle = L.circle([lat, lng], {
                radius: myFacilityRadius * 1609.34, // Convert miles to meters
                color: '#00d4ff',
                fillColor: '#00d4ff',
                fillOpacity: 0.1,
                weight: 3,
                opacity: 0.7,
                dashArray: '10, 10', // Dashed line
                interactive: false  // Allow hover events to pass through
            }).addTo(map);
            
            // Update display
            document.getElementById('myFacilityCoords').textContent = 
                `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
            
            // Show controls
            document.getElementById('myFacilityControls').style.display = 'block';
            
            // Disable placement mode
            disableFacilityPlacement();
            
            // Calculate results
            calculateMyFacilityResults();
        }
        
        // Remove user's facility from map
        function removeMyFacility() {
            if (myFacilityMarker) {
                map.removeLayer(myFacilityMarker);
                myFacilityMarker = null;
            }
            if (myFacilityCircle) {
                map.removeLayer(myFacilityCircle);
                myFacilityCircle = null;
            }
            
            myFacilityLocation = null;
            
            // Hide controls
            document.getElementById('myFacilityControls').style.display = 'none';
            document.getElementById('placeFacilityBtn').style.display = 'block';
            document.getElementById('monthlyBreakdown').style.display = 'none';
            
            // Reset display
            document.getElementById('myFacilityWellCount').textContent = '0';
            document.getElementById('myFacilityAvailableVolume').textContent = '0';
            document.getElementById('myFacilityCapturedVolume').textContent = '0';
            document.getElementById('myFacilityPeriodDays').textContent = '0';
            document.getElementById('myFacilityPeriodRevenue').textContent = '0';
            document.getElementById('myFacilityAnnualizedRevenue').textContent = '0';
            document.getElementById('monthlyBreakdownBody').innerHTML = '';
            
            console.log('Facility removed');
        }
        
        // Update facility service radius
        function updateMyFacilityRadius() {
            if (!myFacilityLocation) return;
            
            // Update circle radius
            if (myFacilityCircle) {
                myFacilityCircle.setRadius(myFacilityRadius * 1609.34);
            }
            
            // Recalculate results
            calculateMyFacilityResults();
        }
        
        // Calculate volume and revenue for user's facility
        function calculateMyFacilityResults() {
            if (!myFacilityLocation || !filteredWellData || filteredWellData.length === 0) {
                return;
            }
            
            console.log('=== Calculating My Facility Results ===');
            console.log('Facility location:', myFacilityLocation);
            console.log('Service radius:', myFacilityRadius, 'miles');
            console.log('Market share:', myFacilityMarketShare, '%');
            console.log('Price per CY:', myFacilityPrice);
            
            // Calculate days in current filter period
            const periodDays = Math.ceil((filterEndDate - filterStartDate) / (1000 * 60 * 60 * 24)) + 1;
            const annualizationFactor = 365 / periodDays;
            
            console.log('Period days:', periodDays);
            console.log('Annualization factor:', annualizationFactor.toFixed(2));
            
            // Find wells within service radius (using aggregated data)
            let wellsInRange = 0;
            let totalAvailableVolume = 0;
            
            filteredWellData.forEach(well => {
                const distance = calculateDistance(
                    myFacilityLocation.lat, 
                    myFacilityLocation.lng,
                    well.lat, 
                    well.lng
                );
                
                if (distance <= myFacilityRadius) {
                    wellsInRange++;
                    totalAvailableVolume += well.quantity || 0;
                }
            });
            
            // Apply market share
            const capturedVolume = totalAvailableVolume * (myFacilityMarketShare / 100);
            
            // Calculate disposal revenue
            const disposalRevenue = capturedVolume * myFacilityPrice;
            
            // Calculate backfill revenue
            const backfillVolume = capturedVolume * (myFacilityBackfillPercentage / 100);
            const backfillRevenue = backfillVolume * myFacilityBackfillPrice;
            
            // Calculate total period revenue
            const periodRevenue = disposalRevenue + backfillRevenue;
            
            // Annualize revenue
            const annualizedRevenue = periodRevenue * annualizationFactor;
            
            console.log('Wells in range:', wellsInRange);
            console.log('Available volume:', totalAvailableVolume.toFixed(2), 'CY');
            console.log('Captured volume:', capturedVolume.toFixed(2), 'CY');
            console.log('Disposal revenue:', disposalRevenue.toFixed(2));
            console.log('Backfill volume:', backfillVolume.toFixed(2), 'CY');
            console.log('Backfill revenue:', backfillRevenue.toFixed(2));
            console.log('Total period revenue:', periodRevenue.toFixed(2));
            console.log('Annualized revenue:', annualizedRevenue.toFixed(2));
            
            // Update display
            document.getElementById('myFacilityWellCount').textContent = formatNumber(wellsInRange);
            document.getElementById('myFacilityAvailableVolume').textContent = formatNumber(totalAvailableVolume, 2);
            document.getElementById('myFacilityCapturedVolume').textContent = formatNumber(capturedVolume, 2);
            document.getElementById('myFacilityDisposalRevenue').textContent = formatNumber(disposalRevenue, 2);
            document.getElementById('myFacilityBackfillRevenue').textContent = formatNumber(backfillRevenue, 2);
            document.getElementById('myFacilityPeriodDays').textContent = formatNumber(periodDays);
            document.getElementById('myFacilityPeriodRevenue').textContent = formatNumber(periodRevenue, 2);
            document.getElementById('myFacilityAnnualizedRevenue').textContent = formatNumber(annualizedRevenue, 2);
            
            // Calculate monthly breakdown
            calculateMonthlyBreakdown();
        }
        
        // Calculate monthly volume and revenue breakdown
        function calculateMonthlyBreakdown() {
            if (!myFacilityLocation || !rawDailyData || rawDailyData.length === 0) {
                document.getElementById('monthlyBreakdown').style.display = 'none';
                return;
            }
            
            console.log('=== Calculating Monthly Breakdown ===');
            
            // Group raw daily data by month for wells in range
            const monthlyData = {};
            
            rawDailyData.forEach(record => {
                // Check if this well is within service radius
                if (!record.lat || !record.lng) return;
                
                const distance = calculateDistance(
                    myFacilityLocation.lat,
                    myFacilityLocation.lng,
                    record.lat,
                    record.lng
                );
                
                if (distance <= myFacilityRadius) {
                    // Check if within date range
                    const recordDate = new Date(record.date);
                    if (recordDate >= filterStartDate && recordDate <= filterEndDate) {
                        // Get month key (YYYY-MM format)
                        const monthKey = `${recordDate.getFullYear()}-${String(recordDate.getMonth() + 1).padStart(2, '0')}`;
                        
                        if (!monthlyData[monthKey]) {
                            monthlyData[monthKey] = {
                                volume: 0,
                                date: recordDate
                            };
                        }
                        
                        monthlyData[monthKey].volume += record.quantity || 0;
                    }
                }
            });
            
            // Sort by date
            const sortedMonths = Object.keys(monthlyData).sort();
            
            if (sortedMonths.length === 0) {
                document.getElementById('monthlyBreakdown').style.display = 'none';
                return;
            }
            
            // Build table
            const tbody = document.getElementById('monthlyBreakdownBody');
            tbody.innerHTML = '';
            
            let totalMonthlyVolume = 0;
            let totalMonthlyRevenue = 0;
            
            sortedMonths.forEach(monthKey => {
                const data = monthlyData[monthKey];
                const capturedVolume = data.volume * (myFacilityMarketShare / 100);
                const revenue = capturedVolume * myFacilityPrice;
                
                totalMonthlyVolume += capturedVolume;
                totalMonthlyRevenue += revenue;
                
                // Format month name
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                                  'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const date = data.date;
                const monthName = `${monthNames[date.getMonth()]} ${date.getFullYear()}`;
                
                const row = document.createElement('tr');
                row.style.borderBottom = '1px solid var(--border)';
                row.innerHTML = `
                    <td style="padding: 0.5rem;">${monthName}</td>
                    <td style="padding: 0.5rem; text-align: right;">${formatNumber(capturedVolume, 0)}</td>
                    <td style="padding: 0.5rem; text-align: right; color: var(--accent); font-weight: 600;">$${formatNumber(revenue, 0)}</td>
                `;
                tbody.appendChild(row);
            });
            
            // Add total row
            const totalRow = document.createElement('tr');
            totalRow.style.fontWeight = 'bold';
            totalRow.style.background = 'var(--bg-card)';
            totalRow.innerHTML = `
                <td style="padding: 0.5rem;">TOTAL</td>
                <td style="padding: 0.5rem; text-align: right;">${formatNumber(totalMonthlyVolume, 0)}</td>
                <td style="padding: 0.5rem; text-align: right; color: var(--accent);">$${formatNumber(totalMonthlyRevenue, 0)}</td>
            `;
            tbody.appendChild(totalRow);
            
            console.log('Monthly breakdown calculated:', sortedMonths.length, 'months');
            document.getElementById('monthlyBreakdown').style.display = 'block';
        }

        // Update date range display
        function updateDateRangeDisplay() {
            const display = document.getElementById('dateRangeDisplay');
            const start = filterStartDate.toLocaleDateString();
            const end = filterEndDate.toLocaleDateString();
            const totalDays = Math.ceil((filterEndDate - filterStartDate) / (1000 * 60 * 60 * 24));
            display.textContent = `Showing data from ${start} to ${end} (${totalDays} days)`;
        }

        // Apply date filter
        function applyDateFilter() {
            const startInput = document.getElementById('startDate').value;
            const endInput = document.getElementById('endDate').value;
            
            if (!startInput || !endInput) {
                alert('Please select both start and end dates');
                return;
            }

            filterStartDate = new Date(startInput);
            filterStartDate.setHours(0, 0, 0, 0); // Start of day
            
            filterEndDate = new Date(endInput);
            filterEndDate.setHours(23, 59, 59, 999); // End of day
            
            if (filterStartDate > filterEndDate) {
                alert('Start date must be before end date');
                return;
            }
            
            console.log('Filter dates:', filterStartDate, 'to', filterEndDate);
            console.log('Total raw daily records:', rawDailyData.length);

            // Re-aggregate with new date range
            clearMapMarkers();
            aggregateWellData();
            addWellMarkers();
            updateDateRangeDisplay();
            updateVolumeCenter(); // Update strategic placement location
            
            // Update draggable facilities if any exist
            if (facilities.length > 0) {
                recalculateFacilities();
            }
            
            updateAnalysis();
        }

        // Reset date filter
        function resetDateFilter() {
            filterStartDate = new Date(minDate);
            filterEndDate = new Date(maxDate);
            
            const minDateInput = new Date(minDate);
            minDateInput.setHours(0, 0, 0, 0);
            const maxDateInput = new Date(maxDate);
            maxDateInput.setHours(0, 0, 0, 0);
            
            document.getElementById('startDate').valueAsDate = minDateInput;
            document.getElementById('endDate').valueAsDate = maxDateInput;
            
            // Reset slider
            sliderStartValue = 0;
            sliderEndValue = 100;
            document.getElementById('dateSliderStart').value = 0;
            document.getElementById('dateSliderEnd').value = 100;
            updateDatesFromSlider();
            
            clearMapMarkers();
            aggregateWellData();
            addWellMarkers();
            updateDateRangeDisplay();
            updateVolumeCenter(); // Update strategic placement location
            
            // Update draggable facilities if any exist
            if (facilities.length > 0) {
                recalculateFacilities();
            }
            
            updateAnalysis();
        }

        // Clear all map markers
        function clearMapMarkers() {
            wellMarkers.forEach(({ marker, tooltip }) => {
                map.removeLayer(marker);
                if (tooltip && tooltip.parentNode) {
                    tooltip.parentNode.removeChild(tooltip);
                }
            });
            wellMarkers = [];
        }

        // Reset app to allow loading a new file
        function resetApp() {
            // Clear all data
            rawDailyData = [];
            wellData = [];
            filteredWellData = [];
            landfills = [];
            selectedLandfills.clear();
            currentRadius = 25;
            maxDistanceFromCenter = 150;
            datasetCenter = null;
            totalOutlierCount = 0;
            selectedFile = null;
            workbookData = null;
            badCoordinateRows = []; // Clear bad coordinates tracking
            
            // Clear map
            if (map) {
                radiusCircles.forEach(circle => map.removeLayer(circle));
                wellMarkers.forEach(marker => map.removeLayer(marker));
                Object.values(landfillMarkers).forEach(marker => map.removeLayer(marker));
                if (centerpointMarker) {
                    map.removeLayer(centerpointMarker);
                }
                if (volumeCenterMarker) {
                    map.removeLayer(volumeCenterMarker);
                }
                if (myFacilityMarker) {
                    map.removeLayer(myFacilityMarker);
                }
                if (myFacilityCircle) {
                    map.removeLayer(myFacilityCircle);
                }
            }
            radiusCircles = [];
            wellMarkers = [];
            landfillMarkers = {};
            centerpointMarker = null;
            volumeCenterMarker = null;
            myFacilityMarker = null;
            myFacilityCircle = null;
            myFacilityLocation = null;
            
            // Reset file input
            document.getElementById('fileInput').value = '';
            document.getElementById('fileName').textContent = 'No file selected';
            
            // Hide all sections
            document.getElementById('globalFiltersSection').style.display = 'none';
            document.getElementById('tabsContainer').style.display = 'none';
            document.getElementById('sheetSelectionSection').style.display = 'none';
            document.getElementById('dateRangeSection').style.display = 'none';
            document.getElementById('landfillSection').style.display = 'none';
            document.getElementById('radiusSection').style.display = 'none';
            document.getElementById('distanceFromCenterSection').style.display = 'none';
            document.getElementById('volumeCenterSection').style.display = 'none';
            document.getElementById('myFacilitySection').style.display = 'none';
            document.getElementById('statsPanel').style.display = 'none';
            document.getElementById('exportBtn').style.display = 'none';
            document.getElementById('resetBtn').style.display = 'none';
            document.getElementById('orlaExportBtn').style.display = 'none';
            document.getElementById('badCoordsExportBtn').style.display = 'none';
            document.getElementById('aiChatPanel').style.display = 'none';
            
            // Show upload section
            document.getElementById('uploadSection').style.display = 'block';
            
            console.log('App reset - ready for new file');
        }

        // Handle file upload
        document.getElementById('fileInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                console.log('=== FILE SELECTED ===');
                console.log('File name:', file.name);
                console.log('File size:', file.size, 'bytes');
                console.log('File type:', file.type);
                
                selectedFile = file;
                document.getElementById('fileName').textContent = file.name;
                
                // Show loading indicator
                const loading = document.getElementById('loading');
                loading.style.display = 'block';
                loading.querySelector('.loading-text').textContent = 'Reading Excel file...';
                
                try {
                    console.log('Reading file as ArrayBuffer...');
                    const arrayBuffer = await file.arrayBuffer();
                    console.log('ArrayBuffer size:', arrayBuffer.byteLength);
                    
                    console.log('Parsing with XLSX...');
                    workbookData = XLSX.read(arrayBuffer, { type: 'array', cellDates: true });
                    console.log('Workbook parsed successfully');
                    console.log('Sheet names:', workbookData.SheetNames);
                    
                    // Populate sheet selector
                    const selector = document.getElementById('sheetSelector');
                    selector.innerHTML = '<option value="">-- Select a worksheet --</option>';
                    
                    workbookData.SheetNames.forEach(sheetName => {
                        const option = document.createElement('option');
                        option.value = sheetName;
                        option.textContent = sheetName;
                        selector.appendChild(option);
                        console.log('Added sheet option:', sheetName);
                    });
                    
                    // Hide loading
                    loading.style.display = 'none';
                    
                    // Show sheet selection section
                    document.getElementById('sheetSelectionSection').style.display = 'block';
                    console.log('Sheet selection section displayed');
                    
                } catch (error) {
                    // Hide loading
                    loading.style.display = 'none';
                    
                    console.error('=== ERROR READING FILE ===');
                    console.error('Error type:', error.name);
                    console.error('Error message:', error.message);
                    console.error('Full error:', error);
                    alert('Error reading Excel file:\n\n' + error.message + '\n\nCheck browser console (F12) for details.');
                }
            } else {
                console.log('No file selected');
            }
        });
        
        // Handle Load Data button click
        document.getElementById('loadSheetBtn').addEventListener('click', () => {
            const selectedSheet = document.getElementById('sheetSelector').value;
            if (!selectedSheet) {
                alert('Please select a worksheet');
                return;
            }
            if (workbookData) {
                loadData(workbookData, selectedSheet);
            }
        });

        // Render landfill selection list
        function renderLandfillList() {
            const container = document.getElementById('landfillList');
            container.innerHTML = '';
            
            landfills.forEach((landfill, index) => {
                const div = document.createElement('div');
                div.className = 'landfill-item';
                div.innerHTML = `
                    <div class="landfill-name">${landfill.site}</div>
                    <div class="landfill-company">${landfill.company}</div>
                `;
                div.onclick = () => toggleLandfill(index, div);
                container.appendChild(div);
            });
        }

        // Toggle landfill selection
        function toggleLandfill(index, element) {
            if (selectedLandfills.has(index)) {
                selectedLandfills.delete(index);
                element.classList.remove('selected');
            } else {
                selectedLandfills.add(index);
                element.classList.add('selected');
            }
            updateAnalysis();
        }

        // Render generator list with checkboxes
        function renderGeneratorList(searchTerm = '') {
            const container = document.getElementById('generatorList');
            container.innerHTML = '';
            
            const filtered = generators.filter(gen => 
                gen.toLowerCase().includes(searchTerm.toLowerCase())
            );
            
            filtered.forEach(generator => {
                const div = document.createElement('div');
                div.className = 'filter-item';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `gen-${generator}`;
                checkbox.checked = selectedGenerators.has(generator);
                checkbox.onchange = () => toggleGenerator(generator);
                
                const label = document.createElement('label');
                label.htmlFor = `gen-${generator}`;
                label.textContent = generator;
                
                div.appendChild(checkbox);
                div.appendChild(label);
                container.appendChild(div);
            });
        }

        // Render transporter list with checkboxes
        function renderTransporterList(searchTerm = '') {
            const container = document.getElementById('transporterList');
            container.innerHTML = '';
            
            const filtered = transporters.filter(trans => 
                trans.toLowerCase().includes(searchTerm.toLowerCase())
            );
            
            filtered.forEach(transporter => {
                const div = document.createElement('div');
                div.className = 'filter-item';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `trans-${transporter}`;
                checkbox.checked = selectedTransporters.has(transporter);
                checkbox.onchange = () => toggleTransporter(transporter);
                
                const label = document.createElement('label');
                label.htmlFor = `trans-${transporter}`;
                label.textContent = transporter;
                
                div.appendChild(checkbox);
                div.appendChild(label);
                container.appendChild(div);
            });
        }

        // Toggle generator selection
        function toggleGenerator(generator) {
            if (selectedGenerators.has(generator)) {
                selectedGenerators.delete(generator);
            } else {
                selectedGenerators.add(generator);
            }
            applyFiltersAndUpdate();
        }

        // Toggle transporter selection
        function toggleTransporter(transporter) {
            if (selectedTransporters.has(transporter)) {
                selectedTransporters.delete(transporter);
            } else {
                selectedTransporters.add(transporter);
            }
            applyFiltersAndUpdate();
        }

        // Apply all filters and update visualization
        function applyFiltersAndUpdate() {
            clearMapMarkers();
            aggregateWellData();
            addWellMarkers();
            updateAnalysis();
        }

        // Helper function to generate consistent well identification key
        // Uses GPS coordinates + destination + generator + transporter
        function getWellKey(well) {
            // Handle missing or invalid coordinates (including zeros)
            if (!well.lat || !well.lng || isNaN(well.lat) || isNaN(well.lng) || 
                Math.abs(well.lat) < 0.0001 || Math.abs(well.lng) < 0.0001) {
                return `GPS:INVALID-${well.destSite}-${well.generator}-${well.transporter}`;
            }
            const latKey = well.lat.toFixed(4);
            const lngKey = well.lng.toFixed(4);
            return `GPS:${latKey},${lngKey}-${well.destSite}-${well.generator}-${well.transporter}`;
        }

        // Add well markers to map
        function addWellMarkers() {
            // Create a Set of filtered well keys for fast lookup
            const filteredKeys = new Set(filteredWellData.map(w => getWellKey(w)));
            
            let markersAdded = 0;
            let markersSkipped = 0;
            
            wellData.forEach(well => {
                // Skip wells without valid coordinates (including zeros)
                if (!well.lat || !well.lng || isNaN(well.lat) || isNaN(well.lng) || 
                    Math.abs(well.lat) < 0.0001 || Math.abs(well.lng) < 0.0001) {
                    markersSkipped++;
                    console.warn('Skipping well with invalid coordinates:', well);
                    return;
                }
                
                // Check if this well is filtered out (by distance from center)
                const wellKey = getWellKey(well);
                const isFiltered = !filteredKeys.has(wellKey);
                
                const marker = L.circleMarker([well.lat, well.lng], {
                    radius: 4,
                    fillColor: isFiltered ? '#808080' : '#4a9eff',  // Grey if filtered, blue if active
                    color: '#fff',
                    weight: 1,
                    opacity: isFiltered ? 0.3 : 0.8,  // More transparent if filtered
                    fillOpacity: isFiltered ? 0.3 : 0.6
                });
                
                const dateRange = well.firstDate && well.lastDate ? 
                    `<strong>Date Range:</strong> ${well.firstDate.toLocaleDateString()} to ${well.lastDate.toLocaleDateString()}<br>` : '';
                
                // Popup (on click)
                marker.bindPopup(`
                    <strong>API #:</strong> ${well.api}<br>
                    <strong>Lease:</strong> ${well.lease}<br>
                    <strong>Operator:</strong> ${well.generator}<br>
                    ${dateRange}
                    <strong>Total Volume:</strong> ${formatNumber(well.quantity, 2)} CY<br>
                    <strong>Number of Loads:</strong> ${well.loadCount}<br>
                    <strong>Destination:</strong> ${well.destSite}<br>
                    ${isFiltered ? '<br><span style="color: #ff6b6b;"><strong>‚ö† Filtered Out (Distance)</strong></span>' : ''}
                `);
                
                // Create tooltip div for hover
                const tooltipDiv = document.createElement('div');
                tooltipDiv.className = 'well-tooltip';
                tooltipDiv.style.cssText = `
                    position: absolute;
                    background: rgba(30, 30, 30, 0.95);
                    color: white;
                    padding: 8px 12px;
                    border-radius: 6px;
                    font-size: 12px;
                    pointer-events: none;
                    z-index: 10000;
                    display: none;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                    border: 1px solid rgba(255,255,255,0.2);
                    max-width: 250px;
                `;
                tooltipDiv.innerHTML = `
                    <div style="font-weight: 600; margin-bottom: 4px; color: ${isFiltered ? '#ff6b6b' : '#4a9eff'};">
                        ${isFiltered ? '‚ö† FILTERED OUT' : '‚úì ACTIVE'}
                    </div>
                    <div><strong>API:</strong> ${well.api}</div>
                    <div><strong>Lease:</strong> ${well.lease}</div>
                    <div><strong>Operator:</strong> ${well.generator}</div>
                    <div><strong>Volume:</strong> ${formatNumber(well.quantity, 2)} CY</div>
                `;
                document.body.appendChild(tooltipDiv);
                
                // Hover events
                marker.on('mouseover', function(e) {
                    const point = map.latLngToContainerPoint(e.latlng);
                    tooltipDiv.style.left = (point.x + 15) + 'px';
                    tooltipDiv.style.top = (point.y - 10) + 'px';
                    tooltipDiv.style.display = 'block';
                });
                
                marker.on('mouseout', function() {
                    tooltipDiv.style.display = 'none';
                });
                
                marker.on('mousemove', function(e) {
                    const point = map.latLngToContainerPoint(e.latlng);
                    tooltipDiv.style.left = (point.x + 15) + 'px';
                    tooltipDiv.style.top = (point.y - 10) + 'px';
                });
                
                marker.addTo(map);
                wellMarkers.push({ marker, data: well, tooltip: tooltipDiv });
                markersAdded++;
            });
            
            console.log(`Added ${markersAdded} markers to map (${markersSkipped} skipped due to invalid coordinates)`);
        }

        // Add landfill markers to map
        function addLandfillMarkers() {
            landfills.forEach((landfill, index) => {
                const marker = L.marker([landfill.lat, landfill.lng], {
                    icon: L.divIcon({
                        className: 'custom-marker',
                        html: `<div style="background: var(--accent); width: 16px; height: 16px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);"></div>`,
                        iconSize: [16, 16],
                        iconAnchor: [8, 8]
                    })
                });
                
                marker.bindPopup(`
                    <strong>${landfill.site}</strong><br>
                    ${landfill.company}
                `);
                
                // Add hover tooltip
                marker.bindTooltip(`
                    <strong>${landfill.site}</strong><br>
                    ${landfill.company}<br>
                    <span style="font-size: 0.9em; opacity: 0.8;">${landfill.lat.toFixed(4)}, ${landfill.lng.toFixed(4)}</span>
                `, {
                    direction: 'top',
                    offset: [0, -10],
                    opacity: 0.95
                });
                
                marker.addTo(map);
                landfillMarkers[index] = marker;
            });
        }

        // Update analysis based on selections
        function updateAnalysis() {
            // Clear existing circles
            radiusCircles.forEach(circle => map.removeLayer(circle));
            radiusCircles = [];

            // Reset well markers based on whether facilities are active
            if (facilities.length > 0) {
                // Facilities active - use facility colors
                updateWellColorsByFacility();
            } else {
                // No facilities - reset to grey/blue
                const filteredKeys = new Set(filteredWellData.map(w => getWellKey(w)));
                wellMarkers.forEach(({ marker, data }) => {
                    const wellKey = getWellKey(data);
                    const isFiltered = !filteredKeys.has(wellKey);
                    
                    marker.setStyle({
                        fillColor: isFiltered ? '#808080' : '#4a9eff',  // Grey if filtered, blue if active
                        radius: 4,
                        opacity: isFiltered ? 0.3 : 0.8,
                        fillOpacity: isFiltered ? 0.3 : 0.6
                    });
                });
            }

            if (selectedLandfills.size === 0) {
                // Use the pre-calculated total outlier count from complete dataset
                const emptyCoordSources = {
                    'Good API #': 0,
                    'GPS Coordinates from EA Data': 0,
                    'Using Center of Indicated County': 0,
                    'Using Center of Landfill County': 0
                };
                updateStats(0, 0, emptyCoordSources, totalOutlierCount);
                return;
            }

            // Draw circles and find wells in range
            let wellsInRange = new Set();
            let totalVolume = 0;
            let coordSourceVolumes = {
                'API Lookup': 0,
                'EA Data': 0,
                'County Centroid': 0,
                'Landfill County': 0
            };

            selectedLandfills.forEach(index => {
                const landfill = landfills[index];
                
                // Draw radius circle
                const circle = L.circle([landfill.lat, landfill.lng], {
                    radius: currentRadius * 1609.34, // Convert miles to meters
                    color: 'var(--primary)',
                    fillColor: 'var(--primary)',
                    fillOpacity: 0.1,
                    weight: 2,
                    opacity: 0.6,
                    interactive: false  // Allow mouse events to pass through to wells underneath
                }).addTo(map);
                radiusCircles.push(circle);

                // Find wells in range that SENT SOIL TO THIS LANDFILL
                wellMarkers.forEach(({ marker, data }, wellIndex) => {
                    // First check if well is within max distance from dataset center
                    let withinCenterDistance = true;
                    let distanceFromCenter = null;
                    if (datasetCenter) {
                        distanceFromCenter = calculateDistance(
                            datasetCenter.lat, datasetCenter.lng,
                            data.lat, data.lng
                        );
                        withinCenterDistance = distanceFromCenter <= maxDistanceFromCenter;
                    }
                    
                    // Only process if within center distance threshold
                    if (!withinCenterDistance) {
                        return; // Skip this well
                    }
                    
                    const distance = calculateDistance(
                        landfill.lat, landfill.lng,
                        data.lat, data.lng
                    );
                    
                    // Check if well is within radius AND sent soil to this specific landfill
                    if (distance <= currentRadius && data.destSite === landfill.site) {
                        wellsInRange.add(wellIndex);
                        totalVolume += data.quantity;
                        
                        // Track volume by coordinate source
                        const source = data.coordSource || 'Unknown';
                        if (coordSourceVolumes.hasOwnProperty(source)) {
                            coordSourceVolumes[source] += data.quantity;
                        }
                        
                        marker.setStyle({
                            fillColor: '#ffd700',
                            radius: 6
                        });
                    }
                });
            });

            // Use pre-calculated total outlier count from complete dataset
            updateStats(wellsInRange.size, totalVolume, coordSourceVolumes, totalOutlierCount);
            
            // Update filtered out count
            updateFilteredOutCount();
        }

        // Update count of wells filtered out by distance from center
        function updateFilteredOutCount() {
            if (!datasetCenter || !wellData || wellData.length === 0) {
                document.getElementById('filteredOutCount').textContent = '0';
                document.getElementById('filteredOutVolume').textContent = '0';
                return;
            }
            
            let filteredCount = 0;
            let filteredVolume = 0;
            wellData.forEach(well => {
                const distance = calculateDistance(
                    datasetCenter.lat, datasetCenter.lng,
                    well.lat, well.lng
                );
                if (distance > maxDistanceFromCenter) {
                    filteredCount++;
                    filteredVolume += well.quantity || 0;
                }
            });
            
            document.getElementById('filteredOutCount').textContent = formatNumber(filteredCount);
            document.getElementById('filteredOutVolume').textContent = formatNumber(filteredVolume, 2);
        }

        // Update statistics display
        function updateStats(wellCount, volume, coordSourceVolumes, outlierCount) {
            document.getElementById('wellCount').textContent = formatNumber(wellCount);
            document.getElementById('totalVolume').textContent = formatNumber(volume, 2);
            document.getElementById('landfillCount').textContent = formatNumber(selectedLandfills.size);
            document.getElementById('outlierCount').textContent = formatNumber(outlierCount || 0);
            
            // Update coordinate source breakdown
            const apiVolume = coordSourceVolumes['API Lookup'] || 0;
            const eaVolume = coordSourceVolumes['EA Data'] || 0;
            const countyVolume = coordSourceVolumes['County Centroid'] || 0;
            const landfillCountyVolume = coordSourceVolumes['Landfill County'] || 0;
            
            document.getElementById('apiCoordVolume').textContent = formatNumber(apiVolume, 2);
            document.getElementById('eaCoordVolume').textContent = formatNumber(eaVolume, 2);
            document.getElementById('countyCoordVolume').textContent = formatNumber(countyVolume, 2);
            document.getElementById('landfillCountyVolume').textContent = formatNumber(landfillCountyVolume, 2);
            
            // Calculate percentages
            if (volume > 0) {
                document.getElementById('apiCoordPct').textContent = ((apiVolume / volume) * 100).toFixed(1);
                document.getElementById('eaCoordPct').textContent = ((eaVolume / volume) * 100).toFixed(1);
                document.getElementById('countyCoordPct').textContent = ((countyVolume / volume) * 100).toFixed(1);
                document.getElementById('landfillCountyPct').textContent = ((landfillCountyVolume / volume) * 100).toFixed(1);
            } else {
                document.getElementById('apiCoordPct').textContent = '0';
                document.getElementById('eaCoordPct').textContent = '0';
                document.getElementById('countyCoordPct').textContent = '0';
                document.getElementById('landfillCountyPct').textContent = '0';
            }
            
            // Show/hide coordinate source panel
            document.getElementById('coordSourcePanel').style.display = wellCount > 0 ? 'block' : 'none';
            
            document.getElementById('exportBtn').disabled = wellCount === 0;
        }

        // =====================================================
// =====================================================
// UNIFIED DRAGGABLE FACILITIES SYSTEM
// =====================================================

// Configuration
let facilitiesConfig = {
    marketShare: 30,
    disposalPrice: 25,
    backfillPrice: 10,
    backfillPercentage: 90,
    minSpacing: 30
};

// Facilities array - main state
let facilities = [];
let nextFacilityId = 1;

// Facility colors (up to 6 facilities)
const facilityColors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#f1c40f'];

// Add a new facility at specified location
function addFacility(lat, lng) {
    if (facilities.length >= 6) {
        alert('Maximum 6 facilities allowed');
        return;
    }
    
    const facility = {
        id: nextFacilityId++,
        lat: lat,
        lng: lng,
        color: facilityColors[facilities.length],
        serviceRadius: 25,  // Default 25 miles
        marker: null,
        circle: null,
        resizeHandle: null,
        wells: [],
        totalVolume: 0,
        capturedVolume: 0,
        disposalRevenue: 0,
        backfillRevenue: 0,
        totalRevenue: 0
    };
    
    facilities.push(facility);
    createFacilityMarker(facility);
    recalculateFacilities();
    updateFacilitiesDisplay();
    
    console.log('Added facility:', facility.id, 'at', lat, lng);
}

// Create draggable marker for facility
function createFacilityMarker(facility) {
    // Create custom icon with number
    const icon = L.divIcon({
        className: 'facility-marker',
        html: `<div style="
            background: ${facility.color};
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 4px solid white;
            box-shadow: 0 0 15px rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            color: white;
            cursor: move;
        ">${facility.id}</div>`,
        iconSize: [36, 36],
        iconAnchor: [18, 18]
    });
    
    // Create draggable marker
    facility.marker = L.marker([facility.lat, facility.lng], {
        icon: icon,
        draggable: true,
        zIndexOffset: 1000
    }).addTo(map);
    
    // Bind popup
    facility.marker.bindPopup(getFacilityPopupContent(facility));
    
    // Drag events
    facility.marker.on('dragstart', function() {
        if (facility.circle) {
            map.removeLayer(facility.circle);
        }
        if (facility.resizeHandle) {
            map.removeLayer(facility.resizeHandle);
        }
    });
    
    facility.marker.on('dragend', function(e) {
        const newPos = e.target.getLatLng();
        facility.lat = newPos.lat;
        facility.lng = newPos.lng;
        
        console.log(`Facility ${facility.id} dragged to:`, facility.lat, facility.lng);
        
        // Recreate circle and resize handle at new position
        createFacilityCircle(facility);
        
        // Recalculate everything
        recalculateFacilities();
        updateFacilitiesDisplay();
        
        // Update popup
        facility.marker.setPopupContent(getFacilityPopupContent(facility));
    });
    
    // Create service radius circle
    createFacilityCircle(facility);
}

// Create service radius circle for facility
function createFacilityCircle(facility) {
    // Remove old circle and handle if they exist
    if (facility.circle) {
        map.removeLayer(facility.circle);
    }
    if (facility.resizeHandle) {
        map.removeLayer(facility.resizeHandle);
    }
    
    // Create service radius circle using facility's own radius
    facility.circle = L.circle([facility.lat, facility.lng], {
        radius: facility.serviceRadius * 1609.34,  // miles to meters
        color: facility.color,
        fillColor: facility.color,
        fillOpacity: 0.1,
        weight: 2,
        interactive: false
    }).addTo(map);
    
    // Calculate position for resize handle (on the circle edge, to the east)
    const handleLat = facility.lat;
    const handleLng = facility.lng + (facility.serviceRadius / 69); // Approximate degrees per mile
    
    // Create resize handle
    facility.resizeHandle = L.marker([handleLat, handleLng], {
        icon: L.divIcon({
            className: 'resize-handle',
            html: `<div style="
                background: ${facility.color};
                width: 12px;
                height: 12px;
                border-radius: 50%;
                border: 2px solid white;
                box-shadow: 0 0 8px rgba(0,0,0,0.4);
                cursor: ew-resize;
            "></div>`,
            iconSize: [12, 12],
            iconAnchor: [6, 6]
        }),
        draggable: true,
        zIndexOffset: 500
    }).addTo(map);
    
    // Create a dynamic label for showing radius during resize
    let radiusLabel = null;
    
    // Handle drag events for resizing
    facility.resizeHandle.on('dragstart', function(e) {
        // Create a tooltip-style label that will follow the drag
        radiusLabel = L.tooltip({
            permanent: true,
            direction: 'top',
            offset: [0, -20],
            className: 'radius-label',
            opacity: 1
        })
        .setLatLng(e.target.getLatLng())
        .setContent(`<strong style="font-size: 14px; color: ${facility.color};">${facility.serviceRadius.toFixed(1)} miles</strong>`)
        .addTo(map);
    });
    
    facility.resizeHandle.on('drag', function(e) {
        const handlePos = e.target.getLatLng();
        const newRadius = calculateDistance(facility.lat, facility.lng, handlePos.lat, handlePos.lng);
        
        // Constrain display (but don't constrain the drag itself yet)
        const displayRadius = Math.max(5, Math.min(200, newRadius));
        
        // Update the circle radius in real-time during drag
        facility.circle.setRadius(newRadius * 1609.34);
        
        // Update the dynamic label
        if (radiusLabel) {
            radiusLabel.setLatLng(handlePos);
            radiusLabel.setContent(`<strong style="font-size: 14px; color: ${facility.color};">${displayRadius.toFixed(1)} miles</strong>`);
        }
    });
    
    facility.resizeHandle.on('dragend', function(e) {
        const handlePos = e.target.getLatLng();
        const newRadius = calculateDistance(facility.lat, facility.lng, handlePos.lat, handlePos.lng);
        
        // Remove the dynamic label
        if (radiusLabel) {
            map.removeLayer(radiusLabel);
            radiusLabel = null;
        }
        
        // Constrain to reasonable bounds (5-200 miles)
        facility.serviceRadius = Math.max(5, Math.min(200, newRadius));
        
        console.log(`Facility ${facility.id} radius changed to ${facility.serviceRadius.toFixed(1)} miles`);
        
        // Recalculate everything with new radius
        recalculateFacilities();
        updateFacilitiesDisplay();
        
        // Redraw circle and handle at correct positions
        createFacilityCircle(facility);
    });
    
    // Bind tooltip to resize handle
    facility.resizeHandle.bindTooltip(`
        <strong>Facility ${facility.id} Radius</strong><br>
        ${facility.serviceRadius.toFixed(1)} miles<br>
        <em style="font-size: 0.9em;">Drag to resize</em>
    `, {
        direction: 'right',
        offset: [10, 0],
        opacity: 0.95
    });
}

// Get popup content for facility
function getFacilityPopupContent(facility) {
    // Calculate period days and CY/day
    const periodDays = Math.ceil((filterEndDate - filterStartDate) / (1000 * 60 * 60 * 24));
    const cyPerDay = facility.capturedVolume / periodDays;
    
    return `
        <div style="min-width: 220px;">
            <strong style="color: ${facility.color}; font-size: 1.1em;">Facility ${facility.id}</strong><br>
            <strong>Location:</strong> ${facility.lat.toFixed(4)}, ${facility.lng.toFixed(4)}<br>
            <strong>Service Radius:</strong> ${facility.serviceRadius.toFixed(1)} miles<br>
            <strong>Wells:</strong> ${formatNumber(facility.wells.length)}<br>
            <strong>Total Volume:</strong> ${formatNumber(facility.totalVolume, 2)} CY<br>
            <strong>Captured Volume:</strong> ${formatNumber(facility.capturedVolume, 2)} CY<br>
            <strong>Volume Rate:</strong> <span style="color: ${facility.color}; font-weight: 600;">${formatNumber(cyPerDay, 2)} CY/day</span><br>
            <hr style="margin: 8px 0;">
            <strong>Annual Revenue:</strong><br>
            <div style="margin-left: 1rem; font-size: 0.95em;">
                Disposal: $${formatNumber(facility.disposalRevenue, 2)}<br>
                Backfill: $${formatNumber(facility.backfillRevenue, 2)}<br>
                <strong>Total: $${formatNumber(facility.totalRevenue, 2)}</strong>
            </div>
            <hr style="margin: 8px 0;">
            <em style="font-size: 0.9em;">üí° Drag marker to reposition<br>üîµ Drag handle to resize radius</em>
        </div>
    `;
}

// Remove a specific facility
function removeFacility(facilityId) {
    const index = facilities.findIndex(f => f.id === facilityId);
    if (index === -1) return;
    
    const facility = facilities[index];
    
    // Remove from map
    if (facility.marker) map.removeLayer(facility.marker);
    if (facility.circle) map.removeLayer(facility.circle);
    if (facility.resizeHandle) map.removeLayer(facility.resizeHandle);
    
    // Remove from array
    facilities.splice(index, 1);
    
    // Renumber IDs sequentially and reassign colors
    facilities.forEach((f, i) => {
        f.id = i + 1;  // Sequential IDs: 1, 2, 3...
        f.color = facilityColors[i];
    });
    
    // Recalculate and update
    if (facilities.length > 0) {
        // Need to recreate markers with new IDs and colors
        facilities.forEach(f => {
            if (f.marker) map.removeLayer(f.marker);
            if (f.circle) map.removeLayer(f.circle);
            if (f.resizeHandle) map.removeLayer(f.resizeHandle);
            createFacilityMarker(f);
        });
        recalculateFacilities();
    } else {
        resetWellColors();
    }
    
    updateFacilitiesDisplay();
    
    console.log('Removed facility, renumbered remaining facilities');
}

// Clear all facilities
function clearAllFacilities() {
    facilities.forEach(facility => {
        if (facility.marker) map.removeLayer(facility.marker);
        if (facility.circle) map.removeLayer(facility.circle);
        if (facility.resizeHandle) map.removeLayer(facility.resizeHandle);
    });
    
    facilities = [];
    nextFacilityId = 1;
    
    resetWellColors();
    updateFacilitiesDisplay();
    
    console.log('Cleared all facilities');
}

// Auto-place facilities using k-means
function autoPlaceFacilities(count) {
    if (!filteredWellData || filteredWellData.length === 0) {
        alert('No data available. Please load data first.');
        return;
    }
    
    if (count < 1 || count > 6) {
        alert('Please specify 1-6 facilities');
        return;
    }
    
    // Clear existing facilities
    clearAllFacilities();
    
    console.log(`Auto-placing ${count} facilities...`);
    
    // Prepare wells data
    const wells = filteredWellData.map(w => ({
        lat: w.lat,
        lng: w.lng,
        volume: w.quantity,
        api: w.api
    }));
    
    if (wells.length === 0) {
        alert('No data available for facility placement.');
        return;
    }
    
    // Run k-means clustering
    const centers = volumeWeightedKMeans(wells, count, facilitiesConfig.minSpacing);
    
    // Add facilities at cluster centers
    centers.forEach(center => {
        addFacility(center.lat, center.lng);
    });
    
    console.log(`Placed ${facilities.length} facilities`);
}

// Volume-weighted k-means clustering
function volumeWeightedKMeans(wells, k, minSpacing, maxIterations = 50) {
    if (wells.length === 0) return [];
    if (k > wells.length) k = wells.length;
    
    // Initialize centers
    let centers = initializeCenters(wells, k, minSpacing);
    
    for (let iter = 0; iter < maxIterations; iter++) {
        // Assign wells to nearest center
        wells.forEach(well => {
            let minDist = Infinity;
            let nearestCenter = 0;
            
            centers.forEach((center, i) => {
                const dist = calculateDistance(well.lat, well.lng, center.lat, center.lng);
                if (dist < minDist) {
                    minDist = dist;
                    nearestCenter = i;
                }
            });
            
            well.assignedCenter = nearestCenter;
        });
        
        // Store old centers
        const oldCenters = centers.map(c => ({lat: c.lat, lng: c.lng}));
        
        // Update centers to volume-weighted mean
        centers.forEach((center, i) => {
            const assignedWells = wells.filter(w => w.assignedCenter === i);
            
            if (assignedWells.length > 0) {
                let totalVolume = 0;
                let weightedLat = 0;
                let weightedLng = 0;
                
                assignedWells.forEach(well => {
                    weightedLat += well.lat * well.volume;
                    weightedLng += well.lng * well.volume;
                    totalVolume += well.volume;
                });
                
                let newLat = weightedLat / totalVolume;
                let newLng = weightedLng / totalVolume;
                
                center.lat = newLat;
                center.lng = newLng;
            }
        });
        
        // Enforce minimum spacing
        enforceMinSpacing(centers, minSpacing);
        
        // Check convergence
        let converged = true;
        for (let i = 0; i < centers.length; i++) {
            const dist = calculateDistance(oldCenters[i].lat, oldCenters[i].lng, centers[i].lat, centers[i].lng);
            if (dist > 0.001) {
                converged = false;
                break;
            }
        }
        
        if (converged) {
            console.log(`K-means converged in ${iter + 1} iterations`);
            break;
        }
    }
    
    return centers;
}

// Initialize k-means centers
function initializeCenters(wells, k, minSpacing) {
    const centers = [];
    const totalVolume = wells.reduce((sum, w) => sum + w.volume, 0);
    
    // First center: volume-weighted random
    let rand = Math.random() * totalVolume;
    let cumulative = 0;
    let firstWell = wells[0];
    
    for (const well of wells) {
        cumulative += well.volume;
        if (cumulative >= rand) {
            firstWell = well;
            break;
        }
    }
    
    centers.push({lat: firstWell.lat, lng: firstWell.lng});
    
    // Subsequent centers: farthest from existing, weighted by volume
    for (let i = 1; i < k; i++) {
        let maxMinDist = -1;
        let bestWell = wells[0];
        
        wells.forEach(well => {
            let minDist = Math.min(...centers.map(c =>
                calculateDistance(well.lat, well.lng, c.lat, c.lng)
            ));
            
            const score = minDist * Math.sqrt(well.volume);
            
            if (score > maxMinDist && minDist >= minSpacing) {
                maxMinDist = score;
                bestWell = well;
            }
        });
        
        centers.push({lat: bestWell.lat, lng: bestWell.lng});
    }
    
    return centers;
}

// Enforce minimum spacing between centers
function enforceMinSpacing(centers, minSpacing) {
    if (minSpacing === 0) return;
    
    for (let i = 0; i < centers.length; i++) {
        for (let j = i + 1; j < centers.length; j++) {
            const dist = calculateDistance(centers[i].lat, centers[i].lng, centers[j].lat, centers[j].lng);
            
            if (dist < minSpacing && dist > 0) {
                const midLat = (centers[i].lat + centers[j].lat) / 2;
                const midLng = (centers[i].lng + centers[j].lng) / 2;
                
                const dLat1 = centers[i].lat - midLat;
                const dLng1 = centers[i].lng - midLng;
                const dLat2 = centers[j].lat - midLat;
                const dLng2 = centers[j].lng - midLng;
                
                const len1 = Math.sqrt(dLat1 * dLat1 + dLng1 * dLng1);
                const len2 = Math.sqrt(dLat2 * dLat2 + dLng2 * dLng2);
                
                if (len1 > 0 && len2 > 0) {
                    const pushDist = (minSpacing - dist) / 2;
                    const latDegPerMile = 1 / 69;
                    const lngDegPerMile = 1 / (69 * Math.cos(midLat * Math.PI / 180));
                    
                    centers[i].lat += (dLat1 / len1) * pushDist * latDegPerMile;
                    centers[i].lng += (dLng1 / len1) * pushDist * lngDegPerMile;
                    centers[j].lat += (dLat2 / len2) * pushDist * latDegPerMile;
                    centers[j].lng += (dLng2 / len2) * pushDist * lngDegPerMile;
                }
            }
        }
    }
}

// Recalculate all facility stats and well assignments
function recalculateFacilities() {
    if (facilities.length === 0) {
        document.getElementById('combinedResults').style.display = 'none';
        return;
    }
    
    console.log('Recalculating facilities...');
    
    // Reset facility stats
    facilities.forEach(facility => {
        facility.wells = [];
        facility.totalVolume = 0;
        facility.coordSourceVolumes = {
            'API Lookup': 0,
            'EA Data': 0,
            'County Centroid': 0,
            'Landfill County': 0
        };
    });
    
    // Assign each well to nearest facility
    filteredWellData.forEach(well => {
        if (!well.lat || !well.lng) return;
        
        let minDist = Infinity;
        let nearestFacility = facilities[0];
        
        facilities.forEach(facility => {
            const dist = calculateDistance(well.lat, well.lng, facility.lat, facility.lng);
            if (dist < minDist) {
                minDist = dist;
                nearestFacility = facility;
            }
        });
        
        // Only count if within this facility's service radius
        if (minDist <= nearestFacility.serviceRadius) {
            nearestFacility.wells.push(well);
            nearestFacility.totalVolume += well.quantity || 0;
            
            // Track volume by coordinate source
            const source = well.coordSource || 'Unknown';
            if (nearestFacility.coordSourceVolumes.hasOwnProperty(source)) {
                nearestFacility.coordSourceVolumes[source] += well.quantity || 0;
            }
        }
    });
    
    // Calculate revenue for each facility
    const periodDays = Math.ceil((filterEndDate - filterStartDate) / (1000 * 60 * 60 * 24));
    const annualizationFactor = 365 / periodDays;
    
    facilities.forEach(facility => {
        facility.capturedVolume = facility.totalVolume * (facilitiesConfig.marketShare / 100);
        
        const disposalRevenue = facility.capturedVolume * facilitiesConfig.disposalPrice;
        const backfillVolume = facility.capturedVolume * (facilitiesConfig.backfillPercentage / 100);
        const backfillRevenue = backfillVolume * facilitiesConfig.backfillPrice;
        
        facility.disposalRevenue = disposalRevenue * annualizationFactor;
        facility.backfillRevenue = backfillRevenue * annualizationFactor;
        facility.totalRevenue = facility.disposalRevenue + facility.backfillRevenue;
        
        // Update popup
        if (facility.marker) {
            facility.marker.setPopupContent(getFacilityPopupContent(facility));
        }
        
        // Update circle
        createFacilityCircle(facility);
    });
    
    // Update well colors
    updateWellColorsByFacility();
    
    // Update combined results
    updateCombinedResults();
    
    console.log('Recalculation complete');
}

// Update well marker colors based on facility assignments
function updateWellColorsByFacility() {
    const filteredKeys = new Set(filteredWellData.map(w => getWellKey(w)));
    
    wellMarkers.forEach(({ marker, data }) => {
        const wellKey = getWellKey(data);
        const isFiltered = !filteredKeys.has(wellKey);
        
        if (isFiltered) {
            // Keep filtered wells grey
            marker.setStyle({
                fillColor: '#808080',
                color: '#ffffff',
                radius: 4,
                opacity: 0.3,
                fillOpacity: 0.3
            });
            return;
        }
        
        // Find which facility this well is assigned to
        let assignedFacility = null;
        for (const facility of facilities) {
            if (facility.wells.some(w => w.api === data.api && w.lease === data.lease)) {
                assignedFacility = facility;
                break;
            }
        }
        
        if (assignedFacility) {
            // Color by facility
            marker.setStyle({
                fillColor: assignedFacility.color,
                color: '#ffffff',
                radius: 4,
                opacity: 0.8,
                fillOpacity: 0.6
            });
        } else {
            // Active but not assigned (outside all radii)
            marker.setStyle({
                fillColor: '#4a9eff',
                color: '#ffffff',
                radius: 4,
                opacity: 0.8,
                fillOpacity: 0.6
            });
        }
    });
}

// Reset well colors to default (grey for filtered, blue for active)
function resetWellColors() {
    const filteredKeys = new Set(filteredWellData.map(w => getWellKey(w)));
    
    wellMarkers.forEach(({ marker, data }) => {
        const wellKey = getWellKey(data);
        const isFiltered = !filteredKeys.has(wellKey);
        
        marker.setStyle({
            fillColor: isFiltered ? '#808080' : '#4a9eff',
            color: '#ffffff',
            radius: 4,
            opacity: isFiltered ? 0.3 : 0.8,
            fillOpacity: isFiltered ? 0.3 : 0.6
        });
    });
}

// Update facilities list display
function updateFacilitiesDisplay() {
    const listDiv = document.getElementById('activeFacilitiesList');
    const container = document.getElementById('facilitiesContainer');
    const countSpan = document.getElementById('facilityCount');
    
    if (facilities.length === 0) {
        listDiv.style.display = 'none';
        return;
    }
    
    listDiv.style.display = 'block';
    countSpan.textContent = facilities.length;
    
    // Calculate period days for CY/day calculation
    const periodDays = Math.ceil((filterEndDate - filterStartDate) / (1000 * 60 * 60 * 24));
    
    const html = facilities.map(facility => {
        // Calculate CY per day
        const cyPerDay = facility.capturedVolume / periodDays;
        
        return `
        <div style="padding: 1rem; background: var(--bg-dark); border-left: 4px solid ${facility.color}; border-radius: 6px; margin-bottom: 0.75rem;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                <strong style="color: ${facility.color}; font-size: 1.05em;">Facility ${facility.id}</strong>
                <button onclick="removeFacility(${facility.id})" style="
                    padding: 0.25rem 0.75rem;
                    background: var(--bg-card);
                    border: 1px solid var(--border);
                    border-radius: 4px;
                    color: var(--text-secondary);
                    cursor: pointer;
                    font-size: 0.85em;
                ">Remove</button>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 0.85em;">
                <div style="color: var(--text-secondary);">Location:</div>
                <div style="font-family: 'Roboto Mono', monospace; font-size: 0.8em;">${facility.lat.toFixed(4)}, ${facility.lng.toFixed(4)}</div>
                <div style="color: var(--text-secondary);">Service Radius:</div>
                <div style="color: ${facility.color}; font-weight: 600;">${facility.serviceRadius.toFixed(1)} miles</div>
                <div style="color: var(--text-secondary);">Wells:</div>
                <div>${formatNumber(facility.wells.length)}</div>
                <div style="color: var(--text-secondary);">Total Volume:</div>
                <div>${formatNumber(facility.totalVolume, 2)} CY</div>
                <div style="color: var(--text-secondary);">Captured Volume:</div>
                <div style="color: ${facility.color}; font-weight: 600;">${formatNumber(facility.capturedVolume, 2)} CY</div>
                <div style="color: var(--text-secondary);">Volume Rate:</div>
                <div style="color: ${facility.color}; font-weight: 600;">${formatNumber(cyPerDay, 2)} CY/day</div>
            </div>
            <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid var(--border);">
                <div style="font-size: 0.85em; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-secondary);">Annual Revenue:</div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 0.85em; padding-left: 1rem;">
                    <div style="color: var(--text-secondary);">Disposal:</div>
                    <div>$${formatNumber(facility.disposalRevenue, 2)}</div>
                    <div style="color: var(--text-secondary);">Backfill:</div>
                    <div>$${formatNumber(facility.backfillRevenue, 2)}</div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 0.85em; margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid var(--border);">
                    <div style="font-weight: 600;">Total:</div>
                    <div style="color: var(--accent); font-weight: 600;">$${formatNumber(facility.totalRevenue, 2)}</div>
                </div>
            </div>
            <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid var(--border); font-size: 0.8em; color: var(--text-secondary);">
                üí° Drag marker to reposition<br>
                üîµ Drag handle to resize radius
            </div>
        </div>
    `}).join('');
    
    container.innerHTML = html;
}

// Update combined results display
function updateCombinedResults() {
    if (facilities.length === 0) {
        document.getElementById('combinedResults').style.display = 'none';
        return;
    }
    
    const totalWells = facilities.reduce((sum, f) => sum + f.wells.length, 0);
    const totalVolume = facilities.reduce((sum, f) => sum + f.totalVolume, 0);
    const totalCaptured = facilities.reduce((sum, f) => sum + f.capturedVolume, 0);
    const totalDisposalAnnual = facilities.reduce((sum, f) => sum + f.disposalRevenue, 0);
    const totalBackfillAnnual = facilities.reduce((sum, f) => sum + f.backfillRevenue, 0);
    const totalRevenueAnnual = facilities.reduce((sum, f) => sum + f.totalRevenue, 0);
    
    // Calculate coordinate source totals
    const coordSourceTotals = {
        'API Lookup': 0,
        'EA Data': 0,
        'County Centroid': 0,
        'Landfill County': 0
    };
    facilities.forEach(f => {
        Object.keys(coordSourceTotals).forEach(source => {
            coordSourceTotals[source] += f.coordSourceVolumes[source] || 0;
        });
    });
    
    // Calculate period factor
    const periodDays = Math.ceil((filterEndDate - filterStartDate) / (1000 * 60 * 60 * 24));
    const periodFactor = periodDays / 365;
    
    // Calculate period revenues
    const totalDisposalPeriod = totalDisposalAnnual * periodFactor;
    const totalBackfillPeriod = totalBackfillAnnual * periodFactor;
    const totalRevenuePeriod = totalRevenueAnnual * periodFactor;
    
    // Update volume stats
    document.getElementById('combinedTotalWells').textContent = formatNumber(totalWells);
    document.getElementById('combinedTotalAvailable').textContent = formatNumber(totalVolume, 2);
    document.getElementById('combinedTotalCaptured').textContent = formatNumber(totalCaptured, 2);
    
    // Update period revenue breakdown
    document.getElementById('combinedDisposalRevenuePeriod').textContent = formatNumber(totalDisposalPeriod, 2);
    document.getElementById('combinedBackfillRevenuePeriod').textContent = formatNumber(totalBackfillPeriod, 2);
    document.getElementById('combinedPeriodRevenue').textContent = formatNumber(totalRevenuePeriod, 2);
    
    // Update annual revenue breakdown
    document.getElementById('combinedDisposalRevenue').textContent = formatNumber(totalDisposalAnnual, 2);
    document.getElementById('combinedBackfillRevenue').textContent = formatNumber(totalBackfillAnnual, 2);
    document.getElementById('combinedAnnualRevenue').textContent = formatNumber(totalRevenueAnnual, 2);
    
    // Update coordinate source breakdown
    document.getElementById('facilityApiCoordVolume').textContent = formatNumber(coordSourceTotals['API Lookup'], 2);
    document.getElementById('facilityEaCoordVolume').textContent = formatNumber(coordSourceTotals['EA Data'], 2);
    document.getElementById('facilityCountyCoordVolume').textContent = formatNumber(coordSourceTotals['County Centroid'], 2);
    document.getElementById('facilityLandfillCountyVolume').textContent = formatNumber(coordSourceTotals['Landfill County'], 2);
    
    // Calculate and update percentages
    if (totalVolume > 0) {
        document.getElementById('facilityApiCoordPct').textContent = ((coordSourceTotals['API Lookup'] / totalVolume) * 100).toFixed(1);
        document.getElementById('facilityEaCoordPct').textContent = ((coordSourceTotals['EA Data'] / totalVolume) * 100).toFixed(1);
        document.getElementById('facilityCountyCoordPct').textContent = ((coordSourceTotals['County Centroid'] / totalVolume) * 100).toFixed(1);
        document.getElementById('facilityLandfillCountyPct').textContent = ((coordSourceTotals['Landfill County'] / totalVolume) * 100).toFixed(1);
    } else {
        document.getElementById('facilityApiCoordPct').textContent = '0';
        document.getElementById('facilityEaCoordPct').textContent = '0';
        document.getElementById('facilityCountyCoordPct').textContent = '0';
        document.getElementById('facilityLandfillCountyPct').textContent = '0';
    }
    
    document.getElementById('combinedResults').style.display = 'block';
}
        // Export to Excel
        function exportToExcel() {
            if (selectedLandfills.size === 0) return;

            const exportData = [];
            
            selectedLandfills.forEach(index => {
                const landfill = landfills[index];
                
                wellMarkers.forEach(({ data }) => {
                    const distance = calculateDistance(
                        landfill.lat, landfill.lng,
                        data.lat, data.lng
                    );
                    
                    // Only include wells within radius that sent soil to this specific landfill
                    if (distance <= currentRadius && data.destSite === landfill.site) {
                        exportData.push({
                            'API #': data.api,
                            'Lease': data.lease,
                            'Wellsite Latitude': data.lat,
                            'Wellsite Longitude': data.lng,
                            'Generator': data.generator,
                            'Transporter': data.transporter,
                            'First Shipment Date': data.firstDate ? data.firstDate.toLocaleDateString() : 'N/A',
                            'Last Shipment Date': data.lastDate ? data.lastDate.toLocaleDateString() : 'N/A',
                            'Number of Loads': data.loadCount,
                            'Destination Landfill': data.destSite,
                            'Destination Company': data.destCompany,
                            'Distance to Landfill (miles)': distance.toFixed(2),
                            'Total Quantity (CY)': data.quantity,
                            'Selected Landfill': landfill.site,
                            'Search Radius (miles)': currentRadius,
                            'Date Filter': `${filterStartDate.toLocaleDateString()} to ${filterEndDate.toLocaleDateString()}`
                        });
                    }
                });
            });

            // Sort by distance
            exportData.sort((a, b) => parseFloat(a['Distance to Landfill (miles)']) - parseFloat(b['Distance to Landfill (miles)']));

            // Create workbook
            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.json_to_sheet(exportData);

            // Set column widths
            ws['!cols'] = [
                { wch: 12 }, // API #
                { wch: 25 }, // Lease
                { wch: 18 }, // Wellsite Lat
                { wch: 18 }, // Wellsite Long
                { wch: 30 }, // Generator
                { wch: 30 }, // Transporter
                { wch: 18 }, // First Shipment Date
                { wch: 18 }, // Last Shipment Date
                { wch: 16 }, // Number of Loads
                { wch: 20 }, // Destination Landfill
                { wch: 20 }, // Destination Company
                { wch: 25 }, // Distance
                { wch: 18 }, // Total Quantity
                { wch: 20 }, // Selected Landfill
                { wch: 22 }, // Search Radius
                { wch: 30 }  // Date Filter
            ];

            XLSX.utils.book_append_sheet(wb, ws, 'Analysis Results');

            // Add summary sheet
            const totalLoads = exportData.reduce((sum, row) => sum + parseInt(row['Number of Loads']), 0);
            const summaryData = [{
                'Total Wells in Range': exportData.length,
                'Total Loads': totalLoads,
                'Total Volume (CY)': exportData.reduce((sum, row) => sum + parseFloat(row['Total Quantity (CY)']), 0).toFixed(2),
                'Search Radius (miles)': currentRadius,
                'Number of Selected Landfills': selectedLandfills.size,
                'Date Range': `${filterStartDate.toLocaleDateString()} to ${filterEndDate.toLocaleDateString()}`,
                'Analysis Date': new Date().toLocaleDateString()
            }];
            const wsSummary = XLSX.utils.json_to_sheet(summaryData);
            XLSX.utils.book_append_sheet(wb, wsSummary, 'Summary');

            // Download
            const timestamp = new Date().toISOString().slice(0, 10);
            XLSX.writeFile(wb, `Soil_Analysis_${timestamp}.xlsx`);
        }

        // Export outlier wells that are more than 100 miles from dataset center
        async function exportOrlaDistantWells() {
            console.log('=== Outlier export function called ===');
            console.log('wellMarkers length:', wellMarkers.length);
            
            try {
                if (!wellMarkers || wellMarkers.length === 0) {
                    alert('No wells to analyze. Please load data first.');
                    return;
                }

                console.log('Calculating centerpoint from', wellMarkers.length, 'wells');

                // Calculate average centerpoint of all wells in the dataset
                let sumLat = 0;
                let sumLng = 0;
                let count = 0;
                
                wellMarkers.forEach(({ data }) => {
                    if (data && !isNaN(data.lat) && !isNaN(data.lng)) {
                        sumLat += data.lat;
                        sumLng += data.lng;
                        count++;
                    }
                });
                
                if (count === 0) {
                    alert('No valid well coordinates found.');
                    return;
                }
                
                const centerLat = sumLat / count;
                const centerLng = sumLng / count;
                
                console.log(`Dataset centerpoint: ${centerLat.toFixed(6)}, ${centerLng.toFixed(6)}`);

                // Show loading message
                document.getElementById('loading').classList.add('active');
                document.getElementById('loading').querySelector('.loading-text').textContent = 'Finding outlier wells over 100 miles...';

                const exportData = [];
                
                // Check ALL wells for distance from centerpoint
                wellMarkers.forEach(({ data }) => {
                    const distance = calculateDistance(
                        centerLat, centerLng,
                        data.lat, data.lng
                    );
                    
                    if (distance > 100) {
                        exportData.push({
                            api: data.api,
                            lease: data.lease,
                            lat: data.lat,
                            lng: data.lng,
                            destSite: data.destSite,
                            destCompany: data.destCompany,
                            distance: distance.toFixed(2),
                            quantity: data.quantity
                        });
                    }
                });

                console.log(`Found ${exportData.length} wells over 100 miles from centerpoint`);

                if (exportData.length === 0) {
                    alert('No wells found more than 100 miles from dataset centerpoint');
                    document.getElementById('loading').classList.remove('active');
                    return;
                }

                // Reverse geocode each well to get location information
                const startTime = Date.now();
                document.getElementById('loading').querySelector('.loading-text').textContent = 
                    `Geocoding ${exportData.length} wells... This will take approximately ${Math.ceil(exportData.length / 60)} minutes.`;

                for (let i = 0; i < exportData.length; i++) {
                    const well = exportData[i];
                    
                    // Update progress more frequently and show percentage
                    if (i % 5 === 0 || i === exportData.length - 1) {
                        const percent = Math.round((i / exportData.length) * 100);
                        const elapsed = Math.round((Date.now() - startTime) / 1000);
                        const estimated = exportData.length > 0 ? Math.round((elapsed / (i + 1)) * (exportData.length - i - 1)) : 0;
                        const etaMin = Math.floor(estimated / 60);
                        const etaSec = estimated % 60;
                        
                        document.getElementById('loading').querySelector('.loading-text').textContent = 
                            `Geocoding: ${i + 1}/${exportData.length} (${percent}%) - ETA: ${etaMin}m ${etaSec}s`;
                    }
                    
                    try {
                        const response = await fetch(
                            `https://nominatim.openstreetmap.org/reverse?format=json&lat=${well.lat}&lon=${well.lng}&zoom=10&addressdetails=1`,
                            {
                                headers: {
                                    'User-Agent': 'Contaminated Soil Analysis Tool'
                                }
                            }
                        );
                        
                        if (response.ok) {
                            const data = await response.json();
                            const address = data.address || {};
                            
                            well.city = address.city || address.town || address.village || address.hamlet || 'N/A';
                            well.county = address.county || 'N/A';
                            well.state = address.state || 'N/A';
                        } else {
                            well.city = 'Geocoding failed';
                            well.county = 'Geocoding failed';
                            well.state = 'Geocoding failed';
                        }
                    } catch (error) {
                        console.error('Geocoding error:', error);
                        well.city = 'Error';
                        well.county = 'Error';
                        well.state = 'Error';
                    }
                    
                    // Add delay to respect rate limits (1 request per second)
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }

                document.getElementById('loading').querySelector('.loading-text').textContent = 
                    'Creating Excel file...';

                // Sort by distance (furthest first)
                exportData.sort((a, b) => parseFloat(b.distance) - parseFloat(a.distance));

                // Format for Excel
                const excelData = exportData.map(well => ({
                    'API #': well.api,
                    'Lease': well.lease,
                    'Wellsite Latitude': well.lat,
                    'Wellsite Longitude': well.lng,
                    'City': well.city,
                    'County': well.county,
                    'State': well.state,
                    'Actual Destination Landfill': well.destSite,
                    'Actual Destination Company': well.destCompany,
                    'Distance from Center (miles)': well.distance,
                    'Quantity (CY)': well.quantity
                }));

                // Create workbook
                const wb = XLSX.utils.book_new();
                const ws = XLSX.utils.json_to_sheet(excelData);

                // Set column widths
                ws['!cols'] = [
                    { wch: 12 }, // API #
                    { wch: 25 }, // Lease
                    { wch: 18 }, // Wellsite Lat
                    { wch: 18 }, // Wellsite Long
                    { wch: 20 }, // City
                    { wch: 20 }, // County
                    { wch: 15 }, // State
                    { wch: 25 }, // Actual Destination Landfill
                    { wch: 25 }, // Actual Destination Company
                    { wch: 28 }, // Distance
                    { wch: 15 }  // Quantity
                ];

                XLSX.utils.book_append_sheet(wb, ws, 'Wells Over 100 Miles');

                // Add summary sheet
                const totalVolume = exportData.reduce((sum, row) => sum + parseFloat(row.quantity), 0);
                const avgDistance = exportData.reduce((sum, row) => sum + parseFloat(row.distance), 0) / exportData.length;
                const maxDistance = Math.max(...exportData.map(row => parseFloat(row.distance)));
                
                // Count by destination
                const destinationCounts = {};
                exportData.forEach(row => {
                    const dest = row.destSite;
                    destinationCounts[dest] = (destinationCounts[dest] || 0) + 1;
                });
                
                // Count by state
                const stateCounts = {};
                exportData.forEach(row => {
                    const state = row.state;
                    stateCounts[state] = (stateCounts[state] || 0) + 1;
                });
                
                const summaryData = [{
                    'Reference Point': 'Dataset Centerpoint',
                    'Centerpoint Latitude': centerLat.toFixed(6),
                    'Centerpoint Longitude': centerLng.toFixed(6),
                    'Distance Threshold': '100 miles',
                    'Total Wells Over 100 Miles': exportData.length,
                    'Total Volume (CY)': totalVolume.toFixed(2),
                    'Average Distance (miles)': avgDistance.toFixed(2),
                    'Maximum Distance (miles)': maxDistance.toFixed(2),
                    'Purpose': 'Data Validation - Check these outlier wells',
                    'Analysis Date': new Date().toLocaleDateString()
                }];
                const wsSummary = XLSX.utils.json_to_sheet(summaryData);
                XLSX.utils.book_append_sheet(wb, wsSummary, 'Summary');
                
                // Add breakdown by actual destination
                const destinationBreakdown = Object.entries(destinationCounts).map(([dest, count]) => ({
                    'Destination Landfill': dest,
                    'Number of Wells': count
                }));
                const wsDestinations = XLSX.utils.json_to_sheet(destinationBreakdown);
                XLSX.utils.book_append_sheet(wb, wsDestinations, 'By Destination');
                
                // Add breakdown by state
                const stateBreakdown = Object.entries(stateCounts).map(([state, count]) => ({
                    'State': state,
                    'Number of Wells': count
                }));
                const wsStates = XLSX.utils.json_to_sheet(stateBreakdown);
                XLSX.utils.book_append_sheet(wb, wsStates, 'By State');

                // Download
                const timestamp = new Date().toISOString().slice(0, 10);
                XLSX.writeFile(wb, `Outlier_Wells_Over_100mi_${timestamp}.xlsx`);
                
                // Reset loading message
                document.getElementById('loading').classList.remove('active');
                document.getElementById('loading').querySelector('.loading-text').textContent = 'Loading data...';
                
            } catch (error) {
                console.error('Error in exportOrlaDistantWells:', error);
                alert('An error occurred while exporting: ' + error.message);
                document.getElementById('loading').classList.remove('active');
                document.getElementById('loading').querySelector('.loading-text').textContent = 'Loading data...';
            }
        }

        // Export rows with bad/missing coordinates to Excel
        async function exportBadCoordinates() {
            console.log('===== EXPORT BAD COORDINATES CALLED =====');
            console.log('badCoordinateRows length:', badCoordinateRows ? badCoordinateRows.length : 'undefined');
            console.log('First 3 items:', badCoordinateRows ? badCoordinateRows.slice(0, 3) : 'undefined');
            
            try {
                if (!badCoordinateRows || badCoordinateRows.length === 0) {
                    alert('No rows with bad coordinates found.');
                    console.log('No bad coordinates to export');
                    return;
                }
                
                console.log(`Preparing to export ${badCoordinateRows.length} rows`);
                
                document.getElementById('loading').classList.add('active');
                document.getElementById('loading').querySelector('.loading-text').textContent = `Preparing export of ${badCoordinateRows.length} rows...`;
                
                // Create workbook
                const wb = XLSX.utils.book_new();
                console.log('Workbook created');
                
                // Create worksheet from bad coordinates data
                const ws = XLSX.utils.json_to_sheet(badCoordinateRows);
                console.log('Worksheet created from data');
                
                // Set column widths for better readability
                const colWidths = [
                    { wch: 10 }, // Priority
                    { wch: 10 }, // Row Number
                    { wch: 15 }, // API Number
                    { wch: 40 }, // Lease
                    { wch: 30 }, // Original Lat (wider for message)
                    { wch: 30 }, // Original Long (wider for message)
                    { wch: 15 }, // Fixed Lat
                    { wch: 15 }, // Fixed Long
                    { wch: 15 }, // County
                    { wch: 20 }, // Destination Company
                    { wch: 20 }, // Destination Site
                    { wch: 25 }, // Generator
                    { wch: 25 }, // Transporter
                    { wch: 12 }, // Date
                    { wch: 10 }, // Quantity
                    { wch: 50 }, // Issue
                    { wch: 20 }, // Status
                    { wch: 50 }  // Action
                ];
                ws['!cols'] = colWidths;
                
                // Add worksheet to workbook
                XLSX.utils.book_append_sheet(wb, ws, 'Bad Coordinates');
                
                // Add a summary sheet
                const fixedCount = badCoordinateRows.filter(r => r.Status === 'Fixed with fallback').length;
                const unfixedCount = badCoordinateRows.filter(r => r.Status === 'Could not fix').length;
                const highPriority = badCoordinateRows.filter(r => r.Priority === 'HIGH').length;
                const mediumPriority = badCoordinateRows.filter(r => r.Priority === 'MEDIUM').length;
                const lowPriority = badCoordinateRows.filter(r => r.Priority === 'LOW').length;
                
                const summary = [
                    { Info: '=== OVERVIEW ===', Value: '' },
                    { Info: 'Total Rows with Originally Bad Coordinates', Value: badCoordinateRows.length },
                    { Info: 'Fixed using county centroid fallback', Value: fixedCount },
                    { Info: 'Could not fix (excluded from analysis)', Value: unfixedCount },
                    { Info: '', Value: '' },
                    { Info: '=== PRIORITY BREAKDOWN ===', Value: '' },
                    { Info: 'HIGH Priority (Has API, coords 0,0)', Value: highPriority },
                    { Info: '  ‚Üí welldatabase.com had no GPS', Value: '' },
                    { Info: '  ‚Üí Try alternative lookup sources!', Value: '' },
                    { Info: 'MEDIUM Priority (Has API, missing coords)', Value: mediumPriority },
                    { Info: 'LOW Priority (No API, used fallback)', Value: lowPriority },
                    { Info: '', Value: '' },
                    { Info: '=== RECOMMENDATION ===', Value: '' },
                    { Info: '1. Sort by Priority column (HIGH first)', Value: '' },
                    { Info: '2. For HIGH priority rows:', Value: '' },
                    { Info: '   - Use API number to lookup elsewhere', Value: '' },
                    { Info: '   - Try state regulatory sites', Value: '' },
                    { Info: '   - Try operator websites', Value: '' },
                    { Info: '   - Google the lease name + API', Value: '' },
                    { Info: '3. For MEDIUM/LOW priority:', Value: '' },
                    { Info: '   - Already using county centroid (acceptable)', Value: '' },
                    { Info: '   - Or manually research if high volume', Value: '' },
                    { Info: '', Value: '' },
                    { Info: 'Export Date', Value: new Date().toLocaleString() }
                ];
                const wsSummary = XLSX.utils.json_to_sheet(summary);
                wsSummary['!cols'] = [{ wch: 50 }, { wch: 15 }];
                XLSX.utils.book_append_sheet(wb, wsSummary, 'Summary');
                
                // Add HIGH PRIORITY sheet for quick action
                const highPriorityRows = badCoordinateRows
                    .filter(r => r.Priority === 'HIGH')
                    .sort((a, b) => {
                        // Sort by quantity (highest first)
                        const qtyA = parseFloat(a.Quantity) || 0;
                        const qtyB = parseFloat(b.Quantity) || 0;
                        return qtyB - qtyA;
                    });
                
                if (highPriorityRows.length > 0) {
                    const wsHigh = XLSX.utils.json_to_sheet(highPriorityRows);
                    wsHigh['!cols'] = colWidths;
                    XLSX.utils.book_append_sheet(wb, wsHigh, 'HIGH PRIORITY - Fix These');
                }
                
                // Generate filename with timestamp
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
                const filename = `Bad_Coordinates_${timestamp}.xlsx`;
                
                // Write file
                XLSX.writeFile(wb, filename);
                
                console.log(`Exported ${badCoordinateRows.length} rows with bad coordinates to ${filename}`);
                
                document.getElementById('loading').classList.remove('active');
                document.getElementById('loading').querySelector('.loading-text').textContent = 'Loading data...';
                
                alert(`Exported ${badCoordinateRows.length} rows with bad coordinates to ${filename}\n\nCheck your Downloads folder.`);
                
            } catch (error) {
                console.error('Error exporting bad coordinates:', error);
                alert('An error occurred while exporting: ' + error.message);
                document.getElementById('loading').classList.remove('active');
                document.getElementById('loading').querySelector('.loading-text').textContent = 'Loading data...';
            }
        }

        // ===== AI ANALYTICS ASSISTANT =====
        
        // Save API key to localStorage
        function saveApiKey() {
            const apiKey = document.getElementById('anthropicApiKey').value.trim();
            if (!apiKey) {
                alert('Please enter an API key');
                return;
            }
            if (!apiKey.startsWith('sk-ant-')) {
                alert('API key should start with sk-ant-');
                return;
            }
            localStorage.setItem('anthropic_api_key', apiKey);
            alert('API key saved! You can now use the AI assistant.');
        }
        
        // Load API key from localStorage
        function loadApiKey() {
            const apiKey = localStorage.getItem('anthropic_api_key');
            if (apiKey) {
                document.getElementById('anthropicApiKey').value = apiKey;
            }
        }
        
        // Toggle AI assistant panel
        function toggleAIAssistant() {
            const content = document.getElementById('aiContent');
            const toggle = document.getElementById('aiToggle');
            
            aiAssistantCollapsed = !aiAssistantCollapsed;
            
            if (aiAssistantCollapsed) {
                content.classList.add('collapsed');
                toggle.classList.add('collapsed');
            } else {
                content.classList.remove('collapsed');
                toggle.classList.remove('collapsed');
            }
        }

        // Ask a suggested question
        function askSuggestion(question) {
            document.getElementById('aiInput').value = question;
            sendAIMessage();
        }

        // Send message to AI
        async function sendAIMessage() {
            const input = document.getElementById('aiInput');
            const question = input.value.trim();
            
            if (!question) return;
            
            // Add user message to chat
            addMessageToChat('user', question);
            input.value = '';
            
            // Disable send button
            const sendBtn = document.getElementById('aiSendBtn');
            sendBtn.disabled = true;
            
            // Show loading indicator
            addLoadingMessage();
            
            try {
                // Get API key
                const apiKey = localStorage.getItem('anthropic_api_key');
                if (!apiKey) {
                    removeLoadingMessage();
                    addMessageToChat('assistant', '‚ö†Ô∏è Please enter your Anthropic API key above and click Save.');
                    sendBtn.disabled = false;
                    return;
                }
                
                // Prepare data context
                const dataContext = prepareDataContext(question);
                
                // Add to conversation history
                conversationHistory.push({
                    role: 'user',
                    content: `${question}\n\nData Context:\n${dataContext}`
                });
                
                // Call Claude API through local proxy
                const response = await fetch('http://localhost:3000/api/claude', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        apiKey: apiKey,
                        messages: conversationHistory
                    })
                });
                
                const data = await response.json();
                
                // Remove loading message
                removeLoadingMessage();
                
                // Check for API errors
                if (data.error) {
                    let errorMsg = 'API Error: ';
                    if (data.error.type === 'authentication_error') {
                        errorMsg += 'Invalid API key. Please check your API key and try again.';
                    } else if (data.error.type === 'rate_limit_error') {
                        errorMsg += 'Rate limit exceeded. Please wait a moment and try again.';
                    } else {
                        errorMsg += data.error.message || 'Unknown error';
                    }
                    addMessageToChat('assistant', errorMsg);
                    sendBtn.disabled = false;
                    return;
                }
                
                // Process response
                if (data.content && data.content.length > 0) {
                    const assistantMessage = data.content[0].text;
                    
                    // Add to conversation history
                    conversationHistory.push({
                        role: 'assistant',
                        content: assistantMessage
                    });
                    
                    // Parse and display response
                    displayAIResponse(assistantMessage);
                } else {
                    addMessageToChat('assistant', 'Sorry, I encountered an error processing your request.');
                }
                
            } catch (error) {
                console.error('AI Assistant Error:', error);
                removeLoadingMessage();
                addMessageToChat('assistant', 'Sorry, I encountered an error: ' + error.message);
            } finally {
                sendBtn.disabled = false;
            }
        }

        // Prepare data context for Claude
        function prepareDataContext(question) {
            const lowerQuestion = question.toLowerCase();
            
            let context = `Dataset Overview:
- Date Range: ${minDate?.toLocaleDateString()} to ${maxDate?.toLocaleDateString()}
- Total Well Sites: ${wellData.length}
- Total Transactions: ${rawDailyData.length}
- Total Volume: ${rawDailyData.reduce((sum, r) => sum + r.quantity, 0).toFixed(2)} CY
- Landfills: ${landfills.map(l => l.site).join(', ')}
- Number of Generators: ${generators.length}
- Number of Transporters: ${transporters.length}

AVAILABLE DATA:
You have access to detailed transaction data. Here's what you can analyze:

`;

            // Always include complete generator data
            const allGenStats = {};
            wellData.forEach(well => {
                const gen = well.generator || 'Unknown';
                if (!allGenStats[gen]) {
                    allGenStats[gen] = { volume: 0, wells: 0, loads: 0 };
                }
                allGenStats[gen].volume += well.quantity;
                allGenStats[gen].wells += 1;
                allGenStats[gen].loads += well.loadCount;
            });
            
            context += `\nALL GENERATORS (${Object.keys(allGenStats).length} total):\n`;
            context += Object.entries(allGenStats)
                .sort((a, b) => b[1].volume - a[1].volume)
                .map(([gen, data]) => `${gen}: ${data.volume.toFixed(2)} CY, ${data.wells} wells, ${data.loads} loads`)
                .join('\n');

            // Always include complete transporter data
            const allTransStats = {};
            wellData.forEach(well => {
                const trans = well.transporter || 'Unknown';
                if (!allTransStats[trans]) {
                    allTransStats[trans] = { volume: 0, wells: 0, loads: 0 };
                }
                allTransStats[trans].volume += well.quantity;
                allTransStats[trans].wells += 1;
                allTransStats[trans].loads += well.loadCount;
            });
            
            context += `\n\nALL TRANSPORTERS (${Object.keys(allTransStats).length} total):\n`;
            context += Object.entries(allTransStats)
                .sort((a, b) => b[1].volume - a[1].volume)
                .map(([trans, data]) => `${trans}: ${data.volume.toFixed(2)} CY, ${data.wells} wells, ${data.loads} loads`)
                .join('\n');

            // Always include landfill breakdown
            const landfillStats = {};
            wellData.forEach(well => {
                const lf = well.destSite || 'Unknown';
                if (!landfillStats[lf]) {
                    landfillStats[lf] = { volume: 0, wells: 0, loads: 0 };
                }
                landfillStats[lf].volume += well.quantity;
                landfillStats[lf].wells += 1;
                landfillStats[lf].loads += well.loadCount;
            });
            
            context += `\n\nALL LANDFILLS:\n`;
            context += Object.entries(landfillStats)
                .sort((a, b) => b[1].volume - a[1].volume)
                .map(([lf, data]) => `${lf}: ${data.volume.toFixed(2)} CY, ${data.wells} wells, ${data.loads} loads`)
                .join('\n');

            // Add detailed time series data
            const monthlyData = {};
            rawDailyData.forEach(row => {
                if (!row.date) return;
                const monthKey = `${row.date.getFullYear()}-${String(row.date.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyData[monthKey]) {
                    monthlyData[monthKey] = { volume: 0, loads: 0 };
                }
                monthlyData[monthKey].volume += row.quantity;
                monthlyData[monthKey].loads += 1;
            });
            
            context += `\n\nMONTHLY BREAKDOWN:\n`;
            context += Object.entries(monthlyData)
                .sort((a, b) => a[0].localeCompare(b[0]))
                .map(([month, data]) => `${month}: ${data.volume.toFixed(2)} CY, ${data.loads} loads`)
                .join('\n');

            // Add distance statistics if relevant
            if (lowerQuestion.includes('distance') || lowerQuestion.includes('haul') || 
                lowerQuestion.includes('mile') || lowerQuestion.includes('far') ||
                lowerQuestion.includes('close') || lowerQuestion.includes('travel')) {
                
                const distanceByTransporter = {};
                wellData.forEach(well => {
                    if (well.landfillLat && well.landfillLng) {
                        const dist = calculateDistance(well.lat, well.lng, well.landfillLat, well.landfillLng);
                        const trans = well.transporter || 'Unknown';
                        if (!distanceByTransporter[trans]) {
                            distanceByTransporter[trans] = { total: 0, count: 0, min: dist, max: dist };
                        }
                        distanceByTransporter[trans].total += dist;
                        distanceByTransporter[trans].count += 1;
                        distanceByTransporter[trans].min = Math.min(distanceByTransporter[trans].min, dist);
                        distanceByTransporter[trans].max = Math.max(distanceByTransporter[trans].max, dist);
                    }
                });
                
                context += `\n\nDISTANCE ANALYSIS BY TRANSPORTER:\n`;
                context += Object.entries(distanceByTransporter)
                    .map(([trans, data]) => {
                        const avg = data.total / data.count;
                        return `${trans}: avg ${avg.toFixed(2)}mi, min ${data.min.toFixed(2)}mi, max ${data.max.toFixed(2)}mi, ${data.count} hauls`;
                    })
                    .join('\n');
            }

            // Add cross-tabulation if asking about relationships
            if (lowerQuestion.includes('by') || lowerQuestion.includes('per') || 
                lowerQuestion.includes('each') || lowerQuestion.includes('breakdown')) {
                
                // Generator x Landfill
                const genLandfill = {};
                wellData.forEach(well => {
                    const gen = well.generator || 'Unknown';
                    const lf = well.destSite || 'Unknown';
                    const key = `${gen}|${lf}`;
                    genLandfill[key] = (genLandfill[key] || 0) + well.quantity;
                });
                
                context += `\n\nGENERATOR x LANDFILL BREAKDOWN (top 20 combinations):\n`;
                context += Object.entries(genLandfill)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 20)
                    .map(([key, vol]) => {
                        const [gen, lf] = key.split('|');
                        return `${gen} ‚Üí ${lf}: ${formatNumber(vol, 2)} CY`;
                    })
                    .join('\n');
            }

            // Add quarter/year analysis if asking about time periods
            if (lowerQuestion.includes('quarter') || lowerQuestion.includes('year') || 
                lowerQuestion.includes('ytd') || lowerQuestion.includes('q1') || 
                lowerQuestion.includes('q2') || lowerQuestion.includes('q3') || lowerQuestion.includes('q4')) {
                
                const quarterlyData = {};
                rawDailyData.forEach(row => {
                    if (!row.date) return;
                    const year = row.date.getFullYear();
                    const quarter = Math.floor(row.date.getMonth() / 3) + 1;
                    const key = `${year}-Q${quarter}`;
                    quarterlyData[key] = (quarterlyData[key] || 0) + row.quantity;
                });
                
                context += `\n\nQUARTERLY BREAKDOWN:\n`;
                context += Object.entries(quarterlyData)
                    .sort((a, b) => a[0].localeCompare(b[0]))
                    .map(([quarter, vol]) => `${quarter}: ${formatNumber(vol, 2)} CY`)
                    .join('\n');
            }

            context += `\n\nINSTRUCTIONS:
- Use the data above to answer the user's question accurately
- Perform calculations, comparisons, and analysis as needed
- If asked for a chart, respond with a JSON code block in this format:

\`\`\`json
{
  "type": "bar|line|pie",
  "title": "Chart Title",
  "data": [
    {"name": "Label1", "value": 123},
    {"name": "Label2", "value": 456}
  ]
}
\`\`\`

- Provide clear insights with specific numbers from the data
- If data isn't available for the specific question, say so and suggest what you can analyze instead`;
            
            return context;
        }

        // Get generator statistics
        function getGeneratorStats() {
            const stats = {};
            wellData.forEach(well => {
                const gen = well.generator || 'Unknown';
                stats[gen] = (stats[gen] || 0) + well.quantity;
            });
            
            return Object.entries(stats)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10)
                .map(([gen, vol]) => `  ${gen}: ${formatNumber(vol, 2)} CY`)
                .join('\n');
        }

        // Get transporter statistics
        function getTransporterStats() {
            const stats = {};
            wellData.forEach(well => {
                const trans = well.transporter || 'Unknown';
                stats[trans] = (stats[trans] || 0) + well.quantity;
            });
            
            return Object.entries(stats)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10)
                .map(([trans, vol]) => `  ${trans}: ${formatNumber(vol, 2)} CY`)
                .join('\n');
        }

        // Get landfill statistics
        function getLandfillStats() {
            const stats = {};
            wellData.forEach(well => {
                const landfill = well.destSite || 'Unknown';
                stats[landfill] = (stats[landfill] || 0) + well.quantity;
            });
            
            return Object.entries(stats)
                .sort((a, b) => b[1] - a[1])
                .map(([landfill, vol]) => `  ${landfill}: ${formatNumber(vol, 2)} CY`)
                .join('\n');
        }

        // Get time series data
        function getTimeSeriesData() {
            const monthlyData = {};
            
            rawDailyData.forEach(row => {
                if (!row.date) return;
                const monthKey = `${row.date.getFullYear()}-${String(row.date.getMonth() + 1).padStart(2, '0')}`;
                monthlyData[monthKey] = (monthlyData[monthKey] || 0) + row.quantity;
            });
            
            return Object.entries(monthlyData)
                .sort((a, b) => a[0].localeCompare(b[0]))
                .map(([month, vol]) => `  ${month}: ${formatNumber(vol, 2)} CY`)
                .join('\n');
        }

        // Get distance statistics
        function getDistanceStats() {
            const distances = [];
            const byTransporter = {};
            
            wellData.forEach(well => {
                if (well.landfillLat && well.landfillLng) {
                    const dist = calculateDistance(well.lat, well.lng, well.landfillLat, well.landfillLng);
                    distances.push(dist);
                    
                    const trans = well.transporter || 'Unknown';
                    if (!byTransporter[trans]) {
                        byTransporter[trans] = { total: 0, count: 0 };
                    }
                    byTransporter[trans].total += dist;
                    byTransporter[trans].count += 1;
                }
            });
            
            const avgDist = distances.length > 0 ? distances.reduce((a, b) => a + b, 0) / distances.length : 0;
            const maxDist = distances.length > 0 ? Math.max(...distances) : 0;
            
            let result = `Average Haul Distance: ${formatNumber(avgDist, 2)} miles\nMaximum Distance: ${formatNumber(maxDist, 2)} miles\n\n`;
            result += 'Top 5 Transporters by Avg Distance:\n';
            
            const topTransporters = Object.entries(byTransporter)
                .map(([name, data]) => ({ name, avg: data.total / data.count }))
                .sort((a, b) => b.avg - a.avg)
                .slice(0, 5);
            
            result += topTransporters.map(t => `  ${t.name}: ${formatNumber(t.avg, 2)} miles`).join('\n');
            
            return result;
        }

        // Display AI response
        function displayAIResponse(message) {
            // Check if message contains JSON chart data
            const jsonMatch = message.match(/```json\n([\s\S]*?)\n```/);
            
            if (jsonMatch) {
                try {
                    const chartData = JSON.parse(jsonMatch[1]);
                    
                    // Extract text before the JSON
                    const textPart = message.substring(0, message.indexOf('```json')).trim();
                    
                    if (textPart) {
                        addMessageToChat('assistant', textPart);
                    }
                    
                    // Render chart
                    renderChart(chartData);
                    
                } catch (error) {
                    console.error('Error parsing chart data:', error);
                    addMessageToChat('assistant', message);
                }
            } else {
                addMessageToChat('assistant', message);
            }
        }

        // Render chart
        function renderChart(chartData) {
            const messagesDiv = document.getElementById('aiMessages');
            const chartContainer = document.createElement('div');
            chartContainer.className = 'ai-message assistant';
            
            const chartDiv = document.createElement('div');
            chartDiv.className = 'ai-chart';
            chartDiv.id = 'chart-' + Date.now();
            
            chartContainer.appendChild(chartDiv);
            messagesDiv.appendChild(chartContainer);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            
            // Use Chart.js to render the chart
            setTimeout(() => {
                const canvas = document.createElement('canvas');
                chartDiv.appendChild(canvas);
                
                const ctx = canvas.getContext('2d');
                
                let chartType = chartData.type || 'bar';
                if (chartType === 'pie') chartType = 'doughnut'; // Chart.js uses doughnut for pie
                
                new Chart(ctx, {
                    type: chartType,
                    data: {
                        labels: chartData.data.map(d => d.name || d.label),
                        datasets: [{
                            label: chartData.title || 'Data',
                            data: chartData.data.map(d => d.value || d.count),
                            backgroundColor: chartType === 'line' ? 'rgba(74, 158, 255, 0.2)' : [
                                '#4a9eff', '#ff6b6b', '#00ff00', '#ffd700', '#ff9f40',
                                '#9966ff', '#4bc0c0', '#ff6384', '#36a2eb', '#ffce56'
                            ],
                            borderColor: '#4a9eff',
                            borderWidth: chartType === 'line' ? 2 : 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            title: {
                                display: true,
                                text: chartData.title || 'Chart'
                            },
                            legend: {
                                display: chartType !== 'line'
                            }
                        },
                        scales: chartType === 'line' || chartType === 'bar' ? {
                            y: {
                                beginAtZero: true
                            }
                        } : {}
                    }
                });
            }, 100);
        }

        // Add message to chat
        function addMessageToChat(role, content) {
            const messagesDiv = document.getElementById('aiMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `ai-message ${role}`;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.textContent = content;
            
            messageDiv.appendChild(contentDiv);
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        // Add loading message
        function addLoadingMessage() {
            const messagesDiv = document.getElementById('aiMessages');
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'ai-loading';
            loadingDiv.id = 'ai-loading-indicator';
            loadingDiv.innerHTML = '<div class="ai-loading-spinner"></div> Analyzing data...';
            messagesDiv.appendChild(loadingDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        // Remove loading message
        function removeLoadingMessage() {
            const loadingDiv = document.getElementById('ai-loading-indicator');
            if (loadingDiv) {
                loadingDiv.remove();
            }
        }

        // Initialize AI Assistant
        function initializeAIAssistant() {
            document.getElementById('aiAssistant').style.display = 'block';
            
            // Load saved API key
            loadApiKey();
            
            // Add welcome message
            addMessageToChat('assistant', 
                `üëã Hi! I'm your AI analytics assistant. I can help you analyze your soil shipment data.\n\n` +
                `‚ö†Ô∏è First, please enter your Anthropic API key above (you can get one at console.anthropic.com).\n\n` +
                `Then try asking me questions like:\n` +
                `‚Ä¢ "Who are the top generators this quarter?"\n` +
                `‚Ä¢ "Show me volume trends by month"\n` +
                `‚Ä¢ "Which transporter has the longest haul distance?"\n` +
                `‚Ä¢ "Compare landfill usage over time"\n\n` +
                `What would you like to know?`
            );
        }

        // Event listeners
        document.getElementById('radiusSlider').addEventListener('input', (e) => {
            currentRadius = parseInt(e.target.value);
            document.getElementById('radiusValue').textContent = currentRadius;
            updateAnalysis();
        });

        // Permian Basin filter checkbox
        document.getElementById('permianBasinOnly').addEventListener('change', (e) => {
            permianBasinOnly = e.target.checked;
            console.log(`Permian Basin filter ${permianBasinOnly ? 'enabled' : 'disabled'}`);
            
            // Re-aggregate data with new filter
            aggregateWellData();
            
            // Recreate well markers with correct colors
            clearMapMarkers();
            addWellMarkers();
            
            // Update volume center with filtered data
            updateVolumeCenter();
            
            // Update draggable facilities if any exist
            if (facilities.length > 0) {
                recalculateFacilities();
            }
            
            // Update analysis and display
            updateAnalysis();
        });

        document.getElementById('maxDistanceSlider').addEventListener('input', (e) => {
            maxDistanceFromCenter = parseInt(e.target.value);
            document.getElementById('maxDistanceValue').textContent = maxDistanceFromCenter;
            
            // Re-aggregate data with new distance filter
            aggregateWellData();
            
            // Recreate well markers with correct colors
            clearMapMarkers();
            addWellMarkers();
            
            // Update volume center with filtered data
            updateVolumeCenter();
            
            // Update draggable facilities if any exist
            if (facilities.length > 0) {
                recalculateFacilities();
            }
            
            // Update analysis and display
            updateAnalysis();
            
            // Update filtered out count
            updateFilteredOutCount();
        });

        // =====================================================
        // DRAGGABLE FACILITIES EVENT LISTENERS
        // =====================================================
        
        // Add Facility button
        document.getElementById('addFacilityBtn').addEventListener('click', () => {
            if (!filteredWellData || filteredWellData.length === 0) {
                alert('Please load data first');
                return;
            }
            
            // Find a smart default location (volume-weighted center of unassigned wells)
            let unassignedWells = filteredWellData;
            
            if (facilities.length > 0) {
                // Filter out wells already assigned to facilities
                const assignedAPIs = new Set();
                facilities.forEach(f => {
                    f.wells.forEach(w => assignedAPIs.add(w.api));
                });
                unassignedWells = filteredWellData.filter(w => !assignedAPIs.has(w.api));
            }
            
            let lat, lng;
            if (unassignedWells.length > 0) {
                // Volume-weighted center of unassigned wells
                let totalVolume = 0;
                let weightedLat = 0;
                let weightedLng = 0;
                
                unassignedWells.forEach(w => {
                    weightedLat += w.lat * w.quantity;
                    weightedLng += w.lng * w.quantity;
                    totalVolume += w.quantity;
                });
                
                lat = weightedLat / totalVolume;
                lng = weightedLng / totalVolume;
            } else {
                // Fallback to dataset center
                lat = datasetCenter.lat;
                lng = datasetCenter.lng;
            }
            
            addFacility(lat, lng);
        });
        
        // Auto-Place All button
        document.getElementById('autoPlaceBtn').addEventListener('click', () => {
            if (!filteredWellData || filteredWellData.length === 0) {
                alert('Please load data first');
                return;
            }
            
            // Prompt for number of facilities
            const count = prompt('How many facilities would you like to place? (1-6)', '3');
            if (!count) return;
            
            const numFacilities = parseInt(count);
            if (isNaN(numFacilities) || numFacilities < 1 || numFacilities > 6) {
                alert('Please enter a number between 1 and 6');
                return;
            }
            
            autoPlaceFacilities(numFacilities);
        });
        
        // Clear All Facilities button
        document.getElementById('clearAllFacilitiesBtn').addEventListener('click', () => {
            if (facilities.length === 0) {
                alert('No facilities to clear');
                return;
            }
            
            if (confirm(`Clear all ${facilities.length} facilities?`)) {
                clearAllFacilities();
            }
        });
        
        
        // Market Share slider
        document.getElementById('facilityMarketShareSlider').addEventListener('input', (e) => {
            facilitiesConfig.marketShare = parseInt(e.target.value);
            document.getElementById('facilityMarketShare').textContent = facilitiesConfig.marketShare;
            
            if (facilities.length > 0) {
                recalculateFacilities();
            }
        });
        
        // Disposal Price input
        document.getElementById('facilityDisposalPrice').addEventListener('input', (e) => {
            facilitiesConfig.disposalPrice = parseFloat(e.target.value) || 0;
            
            if (facilities.length > 0) {
                recalculateFacilities();
            }
        });
        
        // Backfill Price input
        document.getElementById('facilityBackfillPrice').addEventListener('input', (e) => {
            facilitiesConfig.backfillPrice = parseFloat(e.target.value) || 0;
            
            if (facilities.length > 0) {
                recalculateFacilities();
            }
        });
        
        // Backfill Percentage input
        document.getElementById('facilityBackfillPercentage').addEventListener('input', (e) => {
            facilitiesConfig.backfillPercentage = parseFloat(e.target.value) || 0;
            
            if (facilities.length > 0) {
                recalculateFacilities();
            }
        });
        
        // Minimum Spacing slider
        document.getElementById('facilityMinSpacingSlider').addEventListener('input', (e) => {
            facilitiesConfig.minSpacing = parseInt(e.target.value);
            document.getElementById('facilityMinSpacing').textContent = facilitiesConfig.minSpacing;
            // Note: Only affects auto-placement, not manual dragging
        });

        document.getElementById('exportBtn').addEventListener('click', exportToExcel);
        
        // Outlier export button - with detailed debugging
        const orlaBtn = document.getElementById('orlaExportBtn');
        console.log('Looking for orlaExportBtn:', orlaBtn);
        if (orlaBtn) {
            console.log('orlaExportBtn found, adding click listener');
            orlaBtn.addEventListener('click', function(event) {
                console.log('=== BUTTON CLICKED ===');
                console.log('Event:', event);
                try {
                    exportOrlaDistantWells();
                } catch (error) {
                    console.error('Error calling exportOrlaDistantWells:', error);
                    alert('Error: ' + error.message);
                }
            });
            console.log('Outlier export button listener attached successfully');
        } else {
            console.error('Could not find orlaExportBtn element');
        }
        
        // Bad coordinates export button
        const badCoordsBtn = document.getElementById('badCoordsExportBtn');
        if (badCoordsBtn) {
            badCoordsBtn.addEventListener('click', function(event) {
                console.log('Bad coordinates export button clicked');
                try {
                    exportBadCoordinates();
                } catch (error) {
                    console.error('Error calling exportBadCoordinates:', error);
                    alert('Error: ' + error.message);
                }
            });
            console.log('Bad coordinates export button listener attached successfully');
        }
        
        document.getElementById('applyDateFilter').addEventListener('click', applyDateFilter);
        document.getElementById('resetDateFilter').addEventListener('click', resetDateFilter);
        
        // Date slider event listeners
        document.getElementById('dateSliderStart').addEventListener('input', function(e) {
            sliderStartValue = parseFloat(e.target.value);
            updateDatesFromSlider();
        });
        
        document.getElementById('dateSliderEnd').addEventListener('input', function(e) {
            sliderEndValue = parseFloat(e.target.value);
            updateDatesFromSlider();
        });
        
        // Manual date input listeners to update slider
        document.getElementById('startDate').addEventListener('change', updateSliderFromDates);
        document.getElementById('endDate').addEventListener('change', updateSliderFromDates);
        
        // Generator and Transporter search listeners
        document.getElementById('generatorSearch').addEventListener('input', function(e) {
            renderGeneratorList(e.target.value);
        });
        
        document.getElementById('transporterSearch').addEventListener('input', function(e) {
            renderTransporterList(e.target.value);
        });
        
        document.getElementById('clearGenerators').addEventListener('click', function() {
            selectedGenerators.clear();
            renderGeneratorList();
            applyFiltersAndUpdate();
        });
        
        document.getElementById('selectAllGenerators').addEventListener('click', function() {
            selectedGenerators = new Set(generators);
            renderGeneratorList();
            applyFiltersAndUpdate();
        });
        
        document.getElementById('clearTransporters').addEventListener('click', function() {
            selectedTransporters.clear();
            renderTransporterList();
            applyFiltersAndUpdate();
        });
        
        document.getElementById('selectAllTransporters').addEventListener('click', function() {
            selectedTransporters = new Set(transporters);
            renderTransporterList();
            applyFiltersAndUpdate();
        });

        // Initialize and verify libraries
        console.log('=== INITIALIZATION ===');
        console.log('XLSX library loaded:', typeof XLSX !== 'undefined');
        console.log('Leaflet loaded:', typeof L !== 'undefined');
        console.log('File input element:', document.getElementById('fileInput') !== null);
        console.log('Sheet selector element:', document.getElementById('sheetSelector') !== null);
        
        if (typeof XLSX === 'undefined') {
            alert('ERROR: Excel library (XLSX) failed to load. Please refresh the page.');
            console.error('XLSX library not loaded!');
        }
        
        initMap();
    </script>
</body>
</html>
